<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Timeline Settings</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Arial, sans-serif;
      background: #111;
      color: #fff;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
    }

    .header h1 {
      color: #6B7280;
      margin-bottom: 10px;
    }

    .canvas-container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      background: #222;
      border: 2px solid #444;
      border-radius: 8px;
      position: relative;
      aspect-ratio: 16/9;
    }

    .virtual-canvas {
      width: 100%;
      height: 100%;
      position: relative;
      background: linear-gradient(45deg, #1a1a1a 25%, transparent 25%), 
                  linear-gradient(-45deg, #1a1a1a 25%, transparent 25%), 
                  linear-gradient(45deg, transparent 75%, #1a1a1a 75%), 
                  linear-gradient(-45deg, transparent 75%, #1a1a1a 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
      overflow: hidden;
    }

    .milestone {
      width: 24px;
      height: 24px;
      background: #fff;
      border-radius: 50%;
      position: absolute;
      cursor: move;
      z-index: 10;
      transform: translate(-50%, -50%);
    }

    .milestone:hover {
      transform: translate(-50%, -50%) scale(1.2);
    }

    .slide {
      position: absolute;
      color: #fff;
      border-radius: 8px;
      z-index: 8;
      transition: all 0.3s ease;
      overflow: hidden;
      box-sizing: border-box;
      cursor: move;
      background: rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .slide h3 {
      margin: 0 0 5px;
      font-size: 14px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    }
    
    .slide p {
      margin: 0;
      font-size: 10px;
      color: rgba(255, 255, 255, 0.8);
      line-height: 1.2;
    }
    
    .slide .image-placeholder {
      width: 100%;
      height: 80px;
      background: rgba(107, 114, 128, 0.2);
      border: 1px dashed rgba(107, 114, 128, 0.5);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: #6B7280;
      margin-top: 8px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .slide:hover {
      background: rgba(107, 114, 128, 0.2);
    }

    .timeline-path {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }

    .connectors-svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 4;
    }

    .path-line {
      stroke: #6B7280;
      stroke-width: 3;
      fill: none;
      stroke-linecap: round;
      filter: drop-shadow(0 0 4px rgba(107, 114, 128, 0.5));
    }

    .controls {
      max-width: 1200px;
      margin: 20px auto;
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .btn {
      background: #6B7280;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    .btn:hover {
      background: #9932CC;
      transform: translateY(-2px);
    }

    .btn.secondary {
      background: #444;
    }

    .btn.secondary:hover {
      background: #555;
    }

    .info {
      max-width: 1200px;
      margin: 20px auto;
      padding: 15px;
      background: rgba(107, 114, 128, 0.1);
      border: 1px solid #6B7280;
      border-radius: 6px;
      font-size: 14px;
      line-height: 1.5;
    }

    .dragging {
      opacity: 0.8;
      transform: scale(1.1);
      z-index: 20;
    }

    /* Modal Styles */
    .modal {
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(5px);
    }

    .modal-content {
      background: #222;
      margin: 2% auto;
      border-radius: 12px;
      width: 90%;
      max-width: 60%;
      max-height: 90vh;
      border: 1px solid #444;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }

    .modal-header {
      padding: 20px 25px;
      border-bottom: 1px solid #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-body {
      padding: 25px;
    }

    .close {
      color: #aaa;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      transition: color 0.3s ease;
    }

    .close:hover {
      color: #6B7280;
    }

    .templates-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .template-item {
      padding: 15px;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .template-preview {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 120px;
      background: #2a2a2a;
    }

    .shape-preview {
      width: 100%;
      height: 100%;
      max-width: 200px;
      max-height: 100px;
    }

    .template-item:hover {
      background: #3a3a3a;
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(107, 114, 128, 0.2);
    }

    .template-name {
      color: #6B7280;
      font-weight: bold;
      font-size: 16px;
      margin-bottom: 8px;
    }

    .template-desc {
      color: #bbb;
      font-size: 14px;
      line-height: 1.4;
    }

    /* Mini template previews */
    .mini-template {
      background: #2a2a2a;
      border-radius: 4px;
      padding: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 1px solid transparent;
    }

    .mini-template:hover {
      background: #3a3a3a;
      border-color: #6B7280;
      transform: scale(1.05);
    }

    .mini-shape {
      width: 100%;
      height: 100%;
    }

    /* Info button styles */
    .info-button {
      position: absolute;
      top: 15px;
      right: 15px;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: rgba(107, 114, 128, 0.8);
      border: 2px solid rgba(255, 255, 255, 0.3);
      color: #fff;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    }

    .info-button:hover {
      background: rgba(107, 114, 128, 1);
      border-color: rgba(255, 255, 255, 0.6);
      transform: scale(1.1);
      box-shadow: 0 4px 15px rgba(107, 114, 128, 0.4);
    }

    /* Tab navigation styles */
    .tab-navigation {
      display: table;
      border-bottom: 2px solid #333;
      margin-bottom: 20px;
    }

    .tab-button {
      background: #333;
      color: #bbb;
      border: none;
      padding: 12px 20px;
      cursor: pointer;
      border-radius: 6px 6px 0 0;
      margin-right: 5px;
      transition: all 0.3s ease;
      font-size: 14px;
    }

    .tab-button:hover {
      background: #444;
      color: #fff;
    }

    .tab-button.active {
      background: #6B7280;
      color: #fff;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Event editor styles */
    .event-list {
      margin-bottom: 20px;
    }

    .event-item {
      background: #333;
      border-radius: 6px;
      padding: 15px;
      margin-bottom: 10px;
      border-left: 4px solid #6B7280;
    }

    .event-input {
      width: 100%;
      padding: 8px;
      background: #222;
      color: #fff;
      border: 1px solid #555;
      border-radius: 4px;
      margin-bottom: 8px;
      font-size: 12px;
    }

    .event-textarea {
      width: 100%;
      padding: 8px;
      background: #222;
      color: #fff;
      border: 1px solid #555;
      border-radius: 4px;
      margin-bottom: 8px;
      font-size: 12px;
      resize: vertical;
      min-height: 60px;
    }

    /* Responsive design for main layout */
    @media (max-width: 1024px) {
      .main-layout {
        grid-template-columns: 1fr !important;
        height: auto !important;
      }
      .theme-section {
        max-height: 400px;
      }
      
      .tab-navigation {
        flex-wrap: wrap;
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Timeline Settings</h1>
    <button class="btn secondary" onclick="downloadSVG()" style="position: absolute; top: 20px; right: 20px;">
      üì• Download SVG for Figma
    </button>
  </div>

  <!-- Tab Navigation -->
  <div class="tab-navigation" style="max-width: 1200px; margin: 0 auto;">
    <button class="tab-button active" onclick="switchTab('themeAndPath')">üé® Theme & Path</button>
    <button class="tab-button" onclick="switchTab('events')">üìù Events</button>
  </div>

  <!-- Theme and Path Tab Content -->
  <div id="themeAndPath-tab" class="tab-content active">
    <!-- Main two-column layout -->
    <div class="main-layout" style="display: grid; grid-template-columns: 400px 1fr; gap: 30px; margin-top: 20px; height: calc(100vh - 200px);">
      
      <!-- Left Side: Theme Settings -->
      <div class="theme-section" style="padding: 20px; background: #222; border-radius: 8px; overflow-y: auto;">
        <h3 style="color: #6B7280; margin-bottom: 15px;">üé® Theme Settings</h3>
        <div class="theme-controls" style="margin-bottom: 20px;">
          <div style="display: flex; gap: 15px; align-items: center; margin-bottom: 15px;">
            <label style="color: #fff;">Current Theme:</label>
            <select id="theme-selector" onchange="switchTheme()" style="padding: 8px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px; flex: 1;">
              <option value="cosmic">Cosmic Dark</option>
              <option value="minimal">Minimal Light</option>
            </select>
          </div>
        </div>
        <div id="theme-preview" style="padding: 15px; background: #111; border-radius: 6px;">
          <div id="theme-info">
            <strong>Cosmic Dark</strong><br>
            <small style="color: #bbb;">Neutral gray theme with subtle effects</small>
          </div>
          
          <!-- Visual Theme Preview -->
          <div id="theme-visual-preview" style="margin-top: 15px; padding: 12px; background: #111; border-radius: 4px; position: relative;">
            <div style="color: #999; font-size: 11px; margin-bottom: 8px;">Preview:</div>
            <div style="padding: 10px; background: #111; border-radius: 4px; border: 1px solid #333;">
              <svg width="100%" height="60" viewBox="0 0 120 60" style="display: block;">
                <defs>
                  <filter id="pathGlow">
                    <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                    <feMerge> 
                      <feMergeNode in="coloredBlur"/>
                      <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                  </filter>
                </defs>
                <!-- Connector lines -->
                <line id="connector-1" x1="20" y1="45" x2="10" y2="20" stroke="rgba(255,255,255,0.4)" stroke-width="1"/>
                <line id="connector-2" x1="50" y1="45" x2="50" y2="20" stroke="rgba(255,255,255,0.4)" stroke-width="1"/>
                <line id="connector-3" x1="100" y1="45" x2="90" y2="20" stroke="rgba(255,255,255,0.4)" stroke-width="1"/>
                
                <!-- Timeline path -->
                <path id="preview-path" d="M 10 20 Q 30 12 50 20 Q 70 28 90 20" stroke="#6B7280" stroke-width="3" fill="none" filter="url(#pathGlow)"/>
                
                <!-- Milestone circles -->
                <circle id="preview-circle-1" cx="10" cy="20" r="4" fill="#6B7280" stroke="#fff" stroke-width="1.5"/>
                <circle id="preview-circle-2" cx="50" cy="20" r="4" fill="#6B7280" stroke="#fff" stroke-width="1.5"/>
                <circle id="preview-circle-3" cx="90" cy="20" r="4" fill="#6B7280" stroke="#fff" stroke-width="1.5"/>
                
                <!-- Mini slide previews -->
                <rect id="preview-slide-1" x="5" y="42" width="30" height="12" fill="rgba(255,255,255,0.1)" stroke="#6B7280" stroke-width="1" rx="2"/>
                <rect id="preview-slide-2" x="35" y="42" width="30" height="12" fill="rgba(255,255,255,0.1)" stroke="#6B7280" stroke-width="1" rx="2"/>
                <rect id="preview-slide-3" x="85" y="42" width="30" height="12" fill="rgba(255,255,255,0.1)" stroke="#6B7280" stroke-width="1" rx="2"/>
                
                <!-- Mini text in slides -->
                <text x="20" y="50" text-anchor="middle" fill="#fff" font-size="6">Event</text>
                <text x="50" y="50" text-anchor="middle" fill="#fff" font-size="6">Event</text>
                <text x="100" y="50" text-anchor="middle" fill="#fff" font-size="6">Event</text>
              </svg>
            </div>
          </div>
          
          <!-- File Replacement Instructions -->
          <div style="margin-top: 20px; padding: 12px; background: rgba(107, 114, 128, 0.1); border-radius: 4px; border: 1px solid rgba(107, 114, 128, 0.3);">
            <div style="color: #6B7280; font-size: 12px; font-weight: bold; margin-bottom: 6px;">How to Apply Theme:</div>
            <ol style="color: #bbb; font-size: 11px; line-height: 1.4; margin: 0; padding-left: 16px;">
              <li>Click "Download Theme" to get theme.json</li>
              <li>Replace the existing theme.json file in your project</li>
              <li>Refresh your timeline to see the new theme</li>
            </ol>
          </div>
        </div>
                  <button class="btn secondary" onclick="downloadTheme()" style="width: 100%;">üíæ Download Theme</button>

      </div>
      
      <!-- Right Side: Canvas and Controls -->
      <div style="display: flex; flex-direction: column; gap: 20px;">
        
        <div id="template-info" style="padding: 8px; background: rgba(107, 114, 128, 0.1); border-radius: 6px;">
          <strong style="color: #6B7280;">Timeline Template:</strong> 
          <span id="template-name" style="color: #fff; font-weight: normal;">Loading...</span>
        </div>

        <!-- Canvas Instructions -->
        <div style="text-align: center; color: #bbb; font-size: 14px;">
          Drag and drop elements to customize their positions on the 16:9 virtual canvas; or 
          <div class="controls">
            <button class="btn secondary" onclick="automaticallyGeneratePath()">‚ö° Automatically Generate Path</button>
          </div>
        </div>

        <div class="canvas-container" style="flex: 1; position: relative;">
          <button class="info-button" onclick="showTemplatesModal()" title="View Available Templates">
            i
          </button>
          <div class="virtual-canvas" id="canvas">
            <svg class="timeline-path" id="timelinePath">
              <path class="path-line" id="pathLine" d=""></path>
            </svg>
            <svg class="connectors-svg" id="connectorsOverlay">
              <!-- Connector lines will be added here -->
            </svg>
          </div>
        </div>

        <!-- How to Use Instructions -->
        <div style="padding: 15px; background: rgba(107, 114, 128, 0.1); border-radius: 6px; border: 1px solid rgba(107, 114, 128, 0.3);">
          <div style="color: #6B7280; font-size: 14px; font-weight: bold; margin-bottom: 8px;">How to Use:</div>
          <ul style="color: #bbb; font-size: 13px; line-height: 1.4; margin: 0; padding-left: 18px;">
            <li>Gray circles are milestone points (timeline dots)</li>
            <li>Rectangles are slide positions</li>
            <li>Drag and drop elements to reposition them</li>
            <li>The timeline path automatically updates as you move milestones</li>
            <li>Click "Update Timeline" to download a new positions.json file</li>
          </ul>
        </div>

        <div class="controls">
          <button class="btn" onclick="updateTimeline()">üíæ Download New Timeline</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Events Tab Content -->
  <div id="events-tab" class="tab-content" style="max-width: 1200px; margin: 0 auto; padding: 20px;">
    
    <div id="events-list" class="event-list">
      <!-- Events will be loaded here -->
    </div>

    <!-- Add Events button -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
      <button class="btn secondary" onclick="addNewEvent()">+ Add Event</button>
    </div>
    
    <div style="display: flex; gap: 15px; margin-top: 20px; justify-content: center;">
          <!-- Instructions -->
        <div style="margin-top: 30px; padding: 20px; background: rgba(107, 114, 128, 0.1); border-radius: 8px; border: 1px solid rgba(107, 114, 128, 0.3); max-width: 800px; margin-left: auto; margin-right: auto;">
          <div style="color: #6B7280; font-size: 16px; font-weight: bold; margin-bottom: 10px;">üìÅ How to Apply Changes:</div>
          <ol style="color: #bbb; font-size: 14px; line-height: 1.6; margin: 0; padding-left: 20px;">
            <li>Edit events above and click "Save Events"</li>
            <li>Download the generated timeline.js file</li>
            <li>Replace your existing timeline.js file</li>
            <li>Refresh your timeline to see changes</li>
          </ol>
        </div>
      </div>
      <div style="display: flex; gap: 15px; margin-top: 20px; justify-content: center;">
      <button class="btn" onclick="saveEvents()">üíæ Save Events</button>
      <button class="btn secondary" onclick="loadEvents()">üîÑ Reload Events</button>
    </div>
  </div>
    


  <!-- Templates Info Modal -->
  <div id="templates-modal" class="modal" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h2 style="color: #6B7280; margin: 0;">Available Timeline Templates</h2>
        <span class="close" onclick="closeTemplatesModal()">&times;</span>
      </div>
      <div class="modal-body">
        
        <div class="templates-grid">
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 20 20 L 20 60" stroke="#6B7280" stroke-width="2" fill="none"/>
                <circle cx="20" cy="20" r="3" fill="#6B7280"/>
                <circle cx="20" cy="40" r="3" fill="#6B7280"/>
                <circle cx="20" cy="60" r="3" fill="#6B7280"/>
                <rect x="30" y="15" width="25" height="10" fill="none" stroke="#666" stroke-width="1"/>
                <rect x="30" y="35" width="25" height="10" fill="none" stroke="#666" stroke-width="1"/>
                <rect x="30" y="55" width="25" height="10" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">üîÑ Alternating Left Right</div>
            <div class="template-desc">Vertical timeline with slides positioned to the right of milestone dots</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 10 60 L 30 60 L 30 40 L 50 40 L 50 20 L 70 20" stroke="#6B7280" stroke-width="2" fill="none"/>
                <circle cx="10" cy="60" r="3" fill="#6B7280"/>
                <circle cx="30" cy="40" r="3" fill="#6B7280"/>
                <circle cx="50" cy="20" r="3" fill="#6B7280"/>
                <rect x="75" y="15" width="20" height="10" fill="none" stroke="#666" stroke-width="1"/>
                <rect x="75" y="35" width="20" height="10" fill="none" stroke="#666" stroke-width="1"/>
                <rect x="75" y="55" width="20" height="10" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">üìä Stepped Timeline</div>
            <div class="template-desc">Staircase pattern with horizontal steps and vertical transitions</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 10 40 Q 30 20 50 40 Q 70 60 90 40" stroke="#6B7280" stroke-width="2" fill="none"/>
                <circle cx="10" cy="40" r="3" fill="#6B7280"/>
                <circle cx="50" cy="40" r="3" fill="#6B7280"/>
                <circle cx="90" cy="40" r="3" fill="#6B7280"/>
                <rect x="95" y="35" width="20" height="10" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">üåä Curved Centerline</div>
            <div class="template-desc">Elegant S-curve flowing across the canvas with alternating slide placement</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 10 50 Q 30 20 60 40 Q 90 60 110 30" stroke="#6B7280" stroke-width="2" fill="none"/>
                <circle cx="30" cy="30" r="3" fill="#6B7280"/>
                <circle cx="60" cy="40" r="3" fill="#6B7280"/>
                <circle cx="90" cy="50" r="3" fill="#6B7280"/>
                <rect x="85" y="15" width="18" height="8" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">üè¢ Company Milestone Curve</div>
            <div class="template-desc">Professional curved design inspired by corporate timeline layouts</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 60 20 L 80 40 L 60 60 L 40 40 Z" stroke="#6B7280" stroke-width="2" fill="none"/>
                <circle cx="60" cy="20" r="3" fill="#6B7280"/>
                <circle cx="80" cy="40" r="3" fill="#6B7280"/>
                <circle cx="60" cy="60" r="3" fill="#6B7280"/>
                <circle cx="40" cy="40" r="3" fill="#6B7280"/>
                <rect x="85" y="35" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">üíé Diamond Rhombus</div>
            <div class="template-desc">Geometric diamond shape with slides positioned around the perimeter</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 60 25 Q 45 15 35 25 Q 25 35 35 45 Q 45 55 60 45 Q 75 35 60 25" stroke="#6B7280" stroke-width="2" fill="none"/>
                <circle cx="60" cy="25" r="3" fill="#6B7280"/>
                <circle cx="35" cy="35" r="3" fill="#6B7280"/>
                <circle cx="60" cy="45" r="3" fill="#6B7280"/>
                <rect x="80" y="30" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">üíù Heart Teardrop</div>
            <div class="template-desc">Heart-shaped timeline using mathematical cardioid equations</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 60 15 L 70 25 L 80 20 L 75 35 L 85 45 L 70 50 L 75 65 L 60 60 L 45 65 L 50 50 L 35 45 L 45 35 L 40 20 L 50 25 Z" stroke="#6B7280" stroke-width="2" fill="none"/>
                <circle cx="60" cy="15" r="2" fill="#6B7280"/>
                <circle cx="80" cy="20" r="2" fill="#6B7280"/>
                <circle cx="85" cy="45" r="2" fill="#6B7280"/>
                <circle cx="60" cy="60" r="2" fill="#6B7280"/>
                <rect x="90" y="35" width="12" height="6" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">‚≠ê Star Asterisk</div>
            <div class="template-desc">8-pointed star with sharp tips and smooth valleys</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 30 40 Q 20 25 35 30 Q 50 20 55 35 Q 70 25 75 40 Q 90 30 85 45 Q 80 60 65 55 Q 50 65 45 50 Q 30 60 25 45 Q 15 50 30 40" stroke="#6B7280" stroke-width="2" fill="none"/>
                <circle cx="35" cy="30" r="2" fill="#6B7280"/>
                <circle cx="75" cy="40" r="2" fill="#6B7280"/>
                <circle cx="65" cy="55" r="2" fill="#6B7280"/>
                <circle cx="25" cy="45" r="2" fill="#6B7280"/>
                <rect x="90" y="35" width="12" height="6" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">‚òÅÔ∏è Cloud Organic</div>
            <div class="template-desc">Natural cloud-like shape with organic bulges and curves</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 30 40 Q 40 25 60 40 Q 80 55 90 40 Q 80 25 60 40 Q 40 55 30 40" stroke="#6B7280" stroke-width="2" fill="none"/>
                <circle cx="30" cy="40" r="3" fill="#6B7280"/>
                <circle cx="60" cy="40" r="3" fill="#6B7280"/>
                <circle cx="90" cy="40" r="3" fill="#6B7280"/>
                <rect x="95" y="35" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">‚ôæÔ∏è Infinity Loop</div>
            <div class="template-desc">Perfect figure-8 infinity symbol using lemniscate mathematics</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 60 40 Q 50 35 45 45 Q 35 50 30 45 Q 25 40 35 35 Q 45 30 55 35 Q 65 30 75 35 Q 85 40 80 50" stroke="#6B7280" stroke-width="2" fill="none"/>
                <circle cx="60" cy="40" r="3" fill="#6B7280"/>
                <circle cx="45" cy="45" r="3" fill="#6B7280"/>
                <circle cx="30" cy="45" r="3" fill="#6B7280"/>
                <circle cx="75" cy="35" r="3" fill="#6B7280"/>
                <rect x="85" y="45" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">üåÄ Spiral</div>
            <div class="template-desc">Wide spiral pattern expanding from center to edge with multiple rotations</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 10 50 Q 30 30 50 50 Q 70 70 90 50" stroke="#6B7280" stroke-width="2" fill="none"/>
                <circle cx="10" cy="50" r="3" fill="#6B7280"/>
                <circle cx="30" cy="40" r="3" fill="#6B7280"/>
                <circle cx="50" cy="50" r="3" fill="#6B7280"/>
                <circle cx="70" cy="60" r="3" fill="#6B7280"/>
                <circle cx="90" cy="50" r="3" fill="#6B7280"/>
                <rect x="95" y="45" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">„Ä∞Ô∏è Wave</div>
            <div class="template-desc">Smooth wave pattern alternating between upper and lower positions</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 10 40 L 90 40" stroke="#6B7280" stroke-width="2" fill="none"/>
                <circle cx="10" cy="40" r="3" fill="#6B7280"/>
                <circle cx="35" cy="40" r="3" fill="#6B7280"/>
                <circle cx="60" cy="40" r="3" fill="#6B7280"/>
                <circle cx="85" cy="40" r="3" fill="#6B7280"/>
                <rect x="15" y="25" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
                <rect x="40" y="25" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
                <rect x="65" y="25" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
                <rect x="90" y="25" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">üìè Linear</div>
            <div class="template-desc">Classic straight horizontal timeline with evenly spaced milestones</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 60 10 L 60 70" stroke="#6B7280" stroke-width="2" fill="none"/>
                <circle cx="60" cy="15" r="3" fill="#6B7280"/>
                <circle cx="60" cy="35" r="3" fill="#6B7280"/>
                <circle cx="60" cy="55" r="3" fill="#6B7280"/>
                <circle cx="60" cy="70" r="3" fill="#6B7280"/>
                <rect x="30" y="10" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
                <rect x="75" y="30" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
                <rect x="30" y="50" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
                <rect x="75" y="65" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">üìê Vertical</div>
            <div class="template-desc">Vertical timeline flowing from top to bottom</div>
          </div>
        </div>
        
      </div>
    </div>
  </div>


  <div class="info" style="background: #2c3e50; border-color: #34495e;">
    <strong>üì° Server Setup Instructions:</strong>
    <p style="margin: 10px 0;">Run a local server to access this page via HTTP:</p>
    
    <div style="background: #1a252f; padding: 15px; border-radius: 5px; margin: 10px 0; font-family: monospace;">
      <strong style="color: #3498db;">Python (Recommended):</strong><br>
      <code style="color: #e74c3c;">cd /path/to/your/timeline/folder</code><br>
      <code style="color: #e74c3c;">python3 -m http.server 8000</code><br>
      <small style="color: #95a5a6;">Then open: http://localhost:8000/settings.html</small>
    </div>

  <script>
    let positions = {
      virtualCanvas: { width: 1920, height: 1080 },
      milestonePoints: [],
      slidePositions: [],
      pathDefinition: ""
    };

    let currentTemplateName = 'Custom Layout';

    // Function to update template name display
    function updateTemplateDisplay(templateName) {
      currentTemplateName = templateName;
      const templateNameElement = document.getElementById('template-name');
      if (templateNameElement) {
        templateNameElement.textContent = templateName;
      }
    }

    let isDragging = false;
    let dragElement = null;
    let dragOffset = { x: 0, y: 0 };

    // Timeline events data - matches timeline.js
    const events = [
      {
        title: "Feb 2024: Project Start",
        content: 'UN Habitat tasks the innovation team to build a platform to improve cities be smarter. Learn more about the mandate here',
        image: "assets/event1.png"
      },
      {
        title: "Jul 2024: The Innovation team is formed.",
        content: "The team included developers, designers, data analysts, product integration, researchers, and 3 external partners. Meet the team here",
        image: "assets/event2.png"
      },
      {
        title: "Aug 2024: The first demo is delivered live.",
        content: "The demo included an AI chatbot that allows you to ask it on research done with the UN and how to improve each city. It also included a fictional ideal city that can be toured virtually to see what is possible in your city",
        image: ""
      },
      {
        title: "Sep 2024: 8 cities come online on the platform.",
        content: "This allowed the city admins of these cities to access admin panels, dashboard, and AI chatbot dedicated to their cities, which allowed them to make better decisions to improve their cities",
        image: "assets/event4.png"
      },
      {
        title: "Nov 2024: 3 more cities come online.",
        content: "All platforms (including external partners) are now fully integrated within one Data Lake. The UN is also given admin rights to enable them interactions with each live city",
        image: "assets/event5.png"
      },
      {
        title: "Feb 2025: The Quality of Life Initiative platform is delivered",
        content: 'Innovation team delivers the first part of phase one. Onboarding 11 cities out of 100, and allowing cities and city admins data science that can help them improve their cities. You can try it out here',
        image: "assets/event6.png"
      },
      {
        title: "March 2025: Data Collection started.",
        content: "This is the second part of phase one started. The 29 roughly indicators were created by the UN Habitat team in Collaboration with some research. The team partnered with a new vendor Veraset to source mobile ping data from the raw data. We're currently working on mobile ping data & Machine Learning",
        image: "assets/event7.png"
      },
      {
        title: "Dec 2025: End of Phase one",
        content: "We went global and partnered with civic tech leaders around the world.",
        image: ""
      },
      {
        title: "Jan 2026: Start of Phase two",
        content: "We rebuilt everything with AI-driven infrastructure.",
        image: ""
      }
    ];

    async function loadPositions() {
      // Skip fetch if running from file:// protocol to avoid CORS errors
      if (window.location.protocol === 'file:') {
        console.log('Running from file://, using default positions for settings preview');
        useDefaultPositions();
        renderElements();
        return;
      }
      
      try {
        const response = await fetch('positions.json');
        if (response.ok) {
          positions = await response.json();
          console.log('Loaded custom positions:', positions);
          updateTemplateDisplay('Current Layout');
        } else {
          console.warn('positions.json not found, using defaults');
          useDefaultPositions();
        }
      } catch (error) {
        console.warn('Could not load positions.json, using defaults:', error);
        useDefaultPositions();
      }
      renderElements();
    }

    function useDefaultPositions() {
      // Use the current positions from positions.json as the fallback
      // This ensures the settings page shows the actual current positions even when running from file://
      updateTemplateDisplay('Default Layout');
      positions = {
        "virtualCanvas": {
          "width": 1920,
          "height": 1080
        },
        "milestonePoints": [
          {"x": 163.09364548494983, "y": 587.7343265052763},
          {"x": 384, "y": 702},
          {"x": 561.5468227424749, "y": 220.65797641216636},
          {"x": 768, "y": 702},
          {"x": 960, "y": 378},
          {"x": 1152, "y": 702},
          {"x": 1344, "y": 378},
          {"x": 1536, "y": 702},
          {"x": 1728, "y": 378}
        ],
        "slidePositions": [
          {"x": 169.91638795986623, "y": 409.88206083178153},
          {"x": 264, "y": 602},
          {"x": 313.11872909698997, "y": 187.41154562383613},
          {"x": 648, "y": 602},
          {"x": 840, "y": 278},
          {"x": 1032, "y": 602},
          {"x": 1224, "y": 278},
          {"x": 1416, "y": 602},
          {"x": 1608, "y": 278}
        ],
        "pathDefinition": "M 163.09364548494983 587.7343265052763 C 229.3655518394649 587.7343265052763 317.72809364548493 702 384 702 C 437.26404682274244 702 508.28277591973244 220.65797641216636 561.5468227424749 220.65797641216636 C 623.4827759197324 220.65797641216636 706.0640468227425 702 768 702 C 825.6 702 902.4 378 960 378 C 1017.6 378 1094.4 702 1152 702 C 1209.6 702 1286.4 378 1344 378 C 1401.6 378 1478.4 702 1536 702 C 1593.6 702 1670.4 378 1728 378"
      };
    }

    function renderElements() {
      console.log('Rendering elements with positions:', positions);
      const canvas = document.getElementById('canvas');
      
      // Wait for canvas to be properly sized
      setTimeout(() => {
        const canvasRect = canvas.getBoundingClientRect();
        console.log('Canvas dimensions:', canvasRect.width, 'x', canvasRect.height);
        
        if (canvasRect.width === 0 || canvasRect.height === 0) {
          console.warn('Canvas not properly sized, retrying in 100ms');
          setTimeout(renderElements, 100);
          return;
        }
        
        const scaleX = canvasRect.width / positions.virtualCanvas.width;
        const scaleY = canvasRect.height / positions.virtualCanvas.height;
        console.log('Scale factors:', scaleX, scaleY);

        // Clear existing elements
        canvas.querySelectorAll('.milestone, .slide').forEach(el => el.remove());

        // Create milestones
        positions.milestonePoints.forEach((point, index) => {
          const milestone = document.createElement('div');
          milestone.className = 'milestone';
          milestone.dataset.type = 'milestone';
          milestone.dataset.index = index;
          const x = point.x * scaleX;
          const y = point.y * scaleY;
          milestone.style.left = x + 'px';
          milestone.style.top = y + 'px';
          milestone.title = `Milestone ${index + 1}: ${events[index] || 'Event ' + (index + 1)}`;
          console.log(`Created milestone ${index} at (${x}, ${y})`);
          canvas.appendChild(milestone);
        });

        // Create slides with realistic content
        positions.slidePositions.forEach((point, index) => {
          const slide = document.createElement('div');
          slide.className = 'slide';
          slide.dataset.type = 'slide';
          slide.dataset.index = index;
          const x = point.x * scaleX;
          const y = point.y * scaleY;
          
          const event = events[index];
          if (event) {
            // Calculate actual rendered dimensions to match timeline exactly
            const SLIDE_WIDTH = 240; // Fixed width from styles.css
            const hasImage = event.image && event.image.length > 0;
            
            // Calculate text heights (approximate based on actual timeline styling)
            const titleHeight = 25; // H3 with padding-bottom: 10px
            const contentLines = Math.ceil(event.content.length / 50); // ~50 chars per line
            const contentHeight = contentLines * 15; // ~15px per line
            const imageHeight = hasImage ? 120 : 0; // Estimated actual image height
            const imageMargin = hasImage ? 10 : 0;
            const padding = 30; // 15px padding * 2
            
            const calculatedHeight = Math.max(150, titleHeight + contentHeight + imageHeight + imageMargin + padding);
            
            const width = SLIDE_WIDTH * scaleX;
            const height = calculatedHeight * scaleY;
            
            // Create space representation with proportional sections
            let contentHTML = `<div style="height: 100%; display: flex; flex-direction: column;">`;
            
            // Title section (only visible text)
            const titleSectionHeight = (titleHeight / calculatedHeight) * 100;
            contentHTML += `<div style="
              height: ${titleSectionHeight}%; 
              background: rgba(255, 255, 255, 0.1);
              display: table; 
              align-items: center;
              padding: 5px;
              font-size: 11px;
              font-weight: bold;
              color: #fff;
              overflow: hidden;
              text-overflow: ellipsis;
            ">${event.title}</div>`;
            
            // Content section (visual representation)
            const contentSectionHeight = (contentHeight / calculatedHeight) * 100;
            contentHTML += `<div style="
              height: ${contentSectionHeight}%; 
              background: rgba(255, 255, 255, 0.05);
              border-top: 1px solid rgba(255, 255, 255, 0.1);
            "></div>`;
            
            // Image section (if present)
            if (hasImage) {
              const imageSectionHeight = ((imageHeight + imageMargin) / calculatedHeight) * 100;
              contentHTML += `<div style="
                height: ${imageSectionHeight}%; 
                background: rgba(107, 114, 128, 0.15);
                border-top: 1px solid rgba(255, 255, 255, 0.1);
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 8px;
                color: #6B7280;
              ">üì∑</div>`;
            }
            
            contentHTML += `</div>`;
            
            slide.innerHTML = contentHTML;
            slide.style.width = width + 'px';
            slide.style.height = height + 'px';
            slide.style.left = x + 'px';
            slide.style.top = y + 'px';
            slide.title = `${event.title} - Space: ${width.toFixed(0)}√ó${height.toFixed(0)}px`;
            
            console.log(`Slide ${index}: calculated size(${width.toFixed(1)}x${height.toFixed(1)}) at (${x.toFixed(1)}, ${y.toFixed(1)})`);
          } else {
            // Fallback for missing events - use same fixed dimensions as slides.js
            const SLIDE_WIDTH = 240;
            const SLIDE_HEIGHT = 200;
            slide.style.width = (SLIDE_WIDTH * scaleX) + 'px';
            slide.style.height = (SLIDE_HEIGHT * scaleY) + 'px';
            slide.style.left = x + 'px';
            slide.style.top = y + 'px';
            slide.innerHTML = `<div>Event ${index + 1}</div>`;
            slide.title = `Event ${index + 1}`;
          }
          
          canvas.appendChild(slide);
          console.log(`Created slide ${index} at (${x.toFixed(1)}, ${y.toFixed(1)})`);
        });

        updatePath();
        updateConnectors();
        setupDragListeners();
        highlightOverlappingSlides();
        
      }, 50);
    }

    function updatePath() {
      const pathLine = document.getElementById('pathLine');
      if (!pathLine || positions.milestonePoints.length === 0) {
        console.warn('Path line element not found or no milestone points');
        return;
      }

      const canvasRect = document.getElementById('canvas').getBoundingClientRect();
      if (canvasRect.width === 0 || canvasRect.height === 0) {
        console.warn('Canvas not properly sized for path update');
        return;
      }
      
      const scaleX = canvasRect.width / positions.virtualCanvas.width;
      const scaleY = canvasRect.height / positions.virtualCanvas.height;

      // Create path for display (scaled to canvas)
      let displayPath = `M ${positions.milestonePoints[0].x * scaleX} ${positions.milestonePoints[0].y * scaleY}`;
      
      // Create path for export (virtual coordinates)
      let virtualPath = `M ${positions.milestonePoints[0].x} ${positions.milestonePoints[0].y}`;
      
      for (let i = 0; i < positions.milestonePoints.length - 1; i++) {
        const p1 = positions.milestonePoints[i];
        const p2 = positions.milestonePoints[i + 1];
        
        // Display path (scaled)
        const cp1x_display = p1.x * scaleX + (p2.x - p1.x) * scaleX * 0.3;
        const cp1y_display = p1.y * scaleY;
        const cp2x_display = p2.x * scaleX - (p2.x - p1.x) * scaleX * 0.3;
        const cp2y_display = p2.y * scaleY;
        displayPath += ` C ${cp1x_display},${cp1y_display} ${cp2x_display},${cp2y_display} ${p2.x * scaleX},${p2.y * scaleY}`;
        
        // Virtual path (original coordinates)
        const cp1x_virtual = p1.x + (p2.x - p1.x) * 0.3;
        const cp1y_virtual = p1.y;
        const cp2x_virtual = p2.x - (p2.x - p1.x) * 0.3;
        const cp2y_virtual = p2.y;
        virtualPath += ` C ${cp1x_virtual} ${cp1y_virtual} ${cp2x_virtual} ${cp2y_virtual} ${p2.x} ${p2.y}`;
      }
      
      console.log('Setting path:', displayPath);
      pathLine.setAttribute('d', displayPath);
      positions.pathDefinition = virtualPath; // Store virtual coordinates for export
    }

    function updateConnectors() {
      const connectorsOverlay = document.getElementById('connectorsOverlay');
      if (!connectorsOverlay || !positions.milestonePoints || positions.milestonePoints.length === 0) {
        console.warn('Connectors overlay not found or no milestone points');
        return;
      }

      const canvasRect = document.getElementById('canvas').getBoundingClientRect();
      if (canvasRect.width === 0 || canvasRect.height === 0) {
        console.warn('Canvas not properly sized for connector update');
        return;
      }
      
      const scaleX = canvasRect.width / positions.virtualCanvas.width;
      const scaleY = canvasRect.height / positions.virtualCanvas.height;

      // Clear existing connector lines completely (same pattern as updatePath)
      connectorsOverlay.innerHTML = '';

      // Create connector lines between slides and milestones
      positions.slidePositions.forEach((slidePos, index) => {
        if (positions.milestonePoints[index]) {
          const milestone = positions.milestonePoints[index];
          
          // Calculate connection points (scaled to canvas)
          const slideX = slidePos.x * scaleX;
          const slideY = slidePos.y * scaleY;
          const milestoneX = milestone.x * scaleX;
          const milestoneY = milestone.y * scaleY;
          
          // Calculate actual slide dimensions (same logic as renderElements)
          const event = events[index];
          const SLIDE_WIDTH = 240;
          let slideHeight = 200; // Default
          
          if (event) {
            const hasImage = event.image && event.image.length > 0;
            const titleHeight = 25;
            const contentLines = Math.ceil(event.content.length / 50);
            const contentHeight = contentLines * 15;
            const imageHeight = hasImage ? 120 : 0;
            const imageMargin = hasImage ? 10 : 0;
            const padding = 30;
            slideHeight = Math.max(150, titleHeight + contentHeight + imageHeight + imageMargin + padding);
          }
          
          const actualSlideWidth = SLIDE_WIDTH * scaleX;
          const actualSlideHeight = slideHeight * scaleY;
          
          // Create connector line element - connect from slide center to milestone center
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', slideX + actualSlideWidth / 2);
          line.setAttribute('y1', slideY + actualSlideHeight / 2);
          line.setAttribute('x2', milestoneX);
          line.setAttribute('y2', milestoneY);
          line.setAttribute('stroke', 'rgba(255, 255, 255, 0.3)');
          line.setAttribute('stroke-width', '2');
          line.setAttribute('stroke-dasharray', '5,3');
          
          connectorsOverlay.appendChild(line);
        }
      });
    }

    function setupDragListeners() {
      const elements = document.querySelectorAll('.milestone, .slide');
      console.log(`Setting up drag listeners for ${elements.length} elements`);
      
      elements.forEach(element => {
        element.addEventListener('mousedown', startDrag);
      });

      document.addEventListener('mousemove', drag);
      document.addEventListener('mouseup', endDrag);
    }

    function startDrag(e) {
      isDragging = true;
      dragElement = e.target;
      dragElement.classList.add('dragging');
      
      const rect = dragElement.getBoundingClientRect();
      const canvasRect = document.getElementById('canvas').getBoundingClientRect();
      
      dragOffset.x = e.clientX - rect.left - rect.width / 2;
      dragOffset.y = e.clientY - rect.top - rect.height / 2;
      
      e.preventDefault();
    }

    function drag(e) {
      if (!isDragging || !dragElement) return;
      
      const canvas = document.getElementById('canvas');
      const canvasRect = canvas.getBoundingClientRect();
      const scaleX = canvasRect.width / positions.virtualCanvas.width;
      const scaleY = canvasRect.height / positions.virtualCanvas.height;
      
      const x = e.clientX - canvasRect.left - dragOffset.x;
      const y = e.clientY - canvasRect.top - dragOffset.y;
      
      // Constrain to canvas bounds
      const constrainedX = Math.max(0, Math.min(x, canvasRect.width));
      const constrainedY = Math.max(0, Math.min(y, canvasRect.height));
      
      dragElement.style.left = constrainedX + 'px';
      dragElement.style.top = constrainedY + 'px';
      
      // Update positions array
      const type = dragElement.dataset.type;
      const index = parseInt(dragElement.dataset.index);
      const virtualX = constrainedX / scaleX;
      const virtualY = constrainedY / scaleY;
      
      if (type === 'milestone') {
        positions.milestonePoints[index] = { x: virtualX, y: virtualY };
        updatePath();
        // Don't update connectors during drag - only at the end
      } else if (type === 'slide') {
        positions.slidePositions[index] = { x: virtualX, y: virtualY };
        // Don't update connectors during drag - only at the end
        highlightOverlappingSlides(); // Check for overlaps when slide is moved
      }
    }

    function endDrag() {
      if (dragElement) {
        dragElement.classList.remove('dragging');
        dragElement = null;
        
        // Update connectors and check for overlaps after drag ends
        updateConnectors();
        highlightOverlappingSlides();
        
        // Update template name to show it's been customized
        if (currentTemplateName !== 'Custom Layout') {
          updateTemplateDisplay('Custom Layout (Modified)');
        }
        
        // Auto-save positions after dragging (silent save)
        autoSavePositions();
      }
      isDragging = false;
    }
    
    async function autoSavePositions() {
      // Try to save silently to server
      try {
        const response = await fetch('save-positions.php', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(positions)
        });
        
        if (response.ok) {
          console.log('‚úÖ Positions auto-saved');
          showTempMessage('Auto-saved!');
          return;
        }
      } catch (error) {
        console.log('Auto-save to server not available');
      }
      
      // Store positions in localStorage as backup
      localStorage.setItem('timeline-positions', JSON.stringify(positions));
      console.log('Positions stored in localStorage');
    }
    
    function showTempMessage(message) {
      const msg = document.createElement('div');
      msg.textContent = message;
      msg.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #28a745;
        color: white;
        padding: 8px 16px;
        border-radius: 4px;
        z-index: 1000;
        font-size: 14px;
        opacity: 0;
        transition: opacity 0.3s ease;
      `;
      document.body.appendChild(msg);
      
      // Fade in
      setTimeout(() => msg.style.opacity = '1', 10);
      
      // Fade out and remove
      setTimeout(() => {
        msg.style.opacity = '0';
        setTimeout(() => document.body.removeChild(msg), 300);
      }, 2000);
    }

    async function updateTimeline() {
      // Store in localStorage as backup
      localStorage.setItem('timeline-positions', JSON.stringify(positions));
      
      // Generate and download the positions.json file
      const dataStr = JSON.stringify(positions, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(dataBlob);
      
      // Create download link
      const downloadLink = document.createElement('a');
      downloadLink.href = url;
      downloadLink.download = 'positions.json';
      downloadLink.style.display = 'none';
      
      // Trigger download
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);
      
      // Clean up the URL object
      URL.revokeObjectURL(url);
      
      // Show success message with clear instructions
      const message = `‚úÖ New positions.json downloaded!\n\n` +
                     `üìÅ Replace the old positions.json file with the downloaded one\n` +
                     `üîÑ Refresh main timeline to see changes`;
      
      alert(message);
      showTempMessage('üì• positions.json downloaded');
    }
    
    function automaticallyGeneratePath() {
      const eventCount = 9; // Number of events
      const virtualWidth = 1920;
      const virtualHeight = 1080;
      
      // Select a random pattern from available generators
      const patterns = [
        // Professional Timeline Layouts
        generateAlternatingLeftRightPattern,
        generateSteppedTimelinePattern,
        generateCurvedCenterlinePattern,
        generateCompanyMilestoneCurvePattern,
        generateDiamondRhombusPattern,
        generateHeartTeardropPattern,
        generateStarAsteriskPattern,
        generateCloudOrganicPattern,
        generateInfinityLoopPattern,
        generateVerticalBranchPattern,
        generateHorizontalBranchPattern,
        generateDiagonalStepsPattern,
        generateSConnectorPattern,
        generateMilestoneRoadPattern,
        generateFlowingRiverPattern,
        // Keep some original patterns for variety
        generateWavePattern,
        generateSpiralPattern,
        generateLinearPattern,
        generateVerticalPattern
      ];
      
      const selectedPattern = patterns[Math.floor(Math.random() * patterns.length)];
      const result = selectedPattern(eventCount, virtualWidth, virtualHeight);
      
      // Get the pattern name and format it nicely
      const patternName = selectedPattern.name || 'Generated Pattern';
      const displayName = patternName
        .replace(/^generate/, '')
        .replace(/Pattern$/, '')
        .replace(/([A-Z])/g, ' $1')
        .trim()
        .replace(/^\w/, c => c.toUpperCase());
      
      console.log(`Generated pattern: ${patternName}`);
      
      // Update positions
      positions.milestonePoints = result.milestones;
      positions.slidePositions = result.slides;
      positions.pathDefinition = result.pathDefinition;
      
      // Update template name display
      updateTemplateDisplay(displayName);
      
      // Re-render the preview only (no download)
      renderElements();
      
      // Show success message
      showTempMessage('Path generated! Click "Update Timeline" to download.');
    }

    // Pattern Generators
    function generateWavePattern(eventCount, virtualWidth, virtualHeight) {
      const spacing = virtualWidth / (eventCount + 1);
      const upperY = virtualHeight * 0.35;
      const lowerY = virtualHeight * 0.65;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const x = spacing * (i + 1);
        const y = (i % 2 === 0) ? upperY : lowerY;
        
        newMilestones.push({ x, y });
        newSlides.push({ 
          x: x,
          y: y - 150  // Bottom-left corner aligned with dot (slide height is ~150px)
        });
      }
      
      // Enhanced wave curves with varying tangent styles
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        
        // Vary curve tension and tangent behavior
        const curveVariation = i % 4;
        let cp1X, cp1Y, cp2X, cp2Y;
        
        if (curveVariation === 0) {
          // Horizontal tangents - classic S-curve
          cp1X = current.x + (next.x - current.x) * 0.6;
          cp1Y = current.y;
          cp2X = current.x + (next.x - current.x) * 0.4;
          cp2Y = next.y;
        } else if (curveVariation === 1) {
          // Diagonal tangents - more dynamic
          cp1X = current.x + (next.x - current.x) * 0.3;
          cp1Y = current.y + (next.y - current.y) * 0.2;
          cp2X = current.x + (next.x - current.x) * 0.7;
          cp2Y = current.y + (next.y - current.y) * 0.8;
        } else if (curveVariation === 2) {
          // Curved tangents - flowing motion
          const midX = (current.x + next.x) / 2;
          const amplitude = Math.abs(next.y - current.y) * 0.4;
          cp1X = midX - amplitude;
          cp1Y = current.y + (next.y - current.y) * 0.1;
          cp2X = midX + amplitude;
          cp2Y = current.y + (next.y - current.y) * 0.9;
        } else {
          // Sharp tangents - angular transitions
          cp1X = current.x + (next.x - current.x) * 0.8;
          cp1Y = current.y + (next.y - current.y) * 0.1;
          cp2X = current.x + (next.x - current.x) * 0.2;
          cp2Y = current.y + (next.y - current.y) * 0.9;
        }
        
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateZigZagPattern(eventCount, virtualWidth, virtualHeight) {
      const spacing = virtualWidth / (eventCount + 1);
      const topY = virtualHeight * 0.2;
      const bottomY = virtualHeight * 0.8;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const x = spacing * (i + 1);
        const y = (i % 2 === 0) ? topY : bottomY;
        
        newMilestones.push({ x, y });
        newSlides.push({ 
          x: x,
          y: y - 150  // Bottom-left corner aligned with dot (slide height is ~150px)
        });
      }
      
      // Enhanced zigzag with curved transitions and varying sharpness
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        
        // Alternate between sharp angles and smooth curves
        const transitionType = i % 3;
        
        if (transitionType === 0) {
          // Sharp linear transition
          pathDefinition += ` L ${next.x} ${next.y}`;
        } else if (transitionType === 1) {
          // Smooth curved transition
          const cp1X = current.x + (next.x - current.x) * 0.7;
          const cp1Y = current.y;
          const cp2X = current.x + (next.x - current.x) * 0.3;
          const cp2Y = next.y;
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
        } else {
          // Rounded corner transition
          const cornerRadius = 30;
          const cp1X = current.x + (next.x - current.x) * 0.8;
          const cp1Y = current.y + (next.y - current.y) * 0.2;
          const cp2X = current.x + (next.x - current.x) * 0.2;
          const cp2Y = current.y + (next.y - current.y) * 0.8;
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
        }
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateLinearPattern(eventCount, virtualWidth, virtualHeight) {
      const spacing = virtualWidth * 0.8 / (eventCount - 1);
      const startX = virtualWidth * 0.1;
      const centerY = virtualHeight * 0.5;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const x = startX + i * spacing;
        const y = centerY;
        
        newMilestones.push({ x, y });
        newSlides.push({ 
          x: x - 120, // Center slide horizontally on milestone
          y: y - 150  // Position slide above the line
        });
      }
      
      // Create straight horizontal line path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 1; i < newMilestones.length; i++) {
        const curr = newMilestones[i];
        pathDefinition += ` L ${curr.x} ${curr.y}`;
      }
      
      console.log('Linear pattern pathDefinition:', pathDefinition);
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateVerticalPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth * 0.5;
      const spacing = virtualHeight / (eventCount + 1);
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const x = centerX + (Math.sin(i * 0.5) * 200); // Slight wave for visual interest
        const y = spacing * (i + 1);
        
        newMilestones.push({ x, y });
        newSlides.push({ 
          x: x,
          y: y - 150  // Bottom-left corner aligned with dot (slide height is ~150px)
        });
      }
      
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const midY = (current.y + next.y) / 2;
        const cp1X = current.x;
        const cp1Y = current.y + (midY - current.y) * 0.3;
        const cp2X = next.x;
        const cp2Y = next.y - (next.y - midY) * 0.3;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateHorizontalPattern(eventCount, virtualWidth, virtualHeight) {
      const spacing = virtualWidth / (eventCount + 1);
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const x = spacing * (i + 1);
        const y = virtualHeight * 0.5 + (Math.sin(i * 0.8) * 150); // Horizontal with vertical wave
        
        newMilestones.push({ x, y });
        newSlides.push({ 
          x: x,
          y: y - 150  // Bottom-left corner aligned with dot (slide height is ~150px)
        });
      }
      
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const midX = (current.x + next.x) / 2;
        const cp1X = current.x + (midX - current.x) * 0.4;
        const cp1Y = current.y;
        const cp2X = next.x - (next.x - midX) * 0.4;
        const cp2Y = next.y;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateSpiralPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth * 0.5;
      const centerY = virtualHeight * 0.5;
      const maxRadius = Math.min(virtualWidth, virtualHeight) * 0.48; // Maximum spread - nearly edge to edge
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        // Create more spacing between spiral arms by using fewer rotations but more gradual expansion
        const progress = i / (eventCount - 1);
        const angle = progress * 5 * Math.PI; // 2.5 rotations for wider arm spacing
        
        // Use progressive radius expansion that matches your sketch - starts slow, accelerates
        const radiusProgress = Math.pow(progress, 0.7); // Curved expansion like your drawing
        const radius = radiusProgress * maxRadius;
        
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;
        
        newMilestones.push({ x, y });
        
        // Position slides tangentially to the spiral curve with better spacing
        const slideRadius = radius + 120; // More space from spiral
        const slideAngle = angle + Math.PI/3; // Better angular offset
        const slideX = centerX + Math.cos(slideAngle) * slideRadius;
        const slideY = centerY + Math.sin(slideAngle) * slideRadius - 75;
        
        newSlides.push({ 
          x: slideX,
          y: slideY
        });
      }
      
      // Enhanced spiral with varying curve tensions and tangent directions
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        
        // Calculate tangent direction based on spiral rotation
        const currentAngle = (i / eventCount) * 4 * Math.PI;
        const nextAngle = ((i + 1) / eventCount) * 4 * Math.PI;
        
        // Vary control point placement for different spiral segments
        const spiralVariation = Math.floor(i / (eventCount / 4)) % 3;
        let cp1X, cp1Y, cp2X, cp2Y;
        
        if (spiralVariation === 0) {
          // Tight spiral curves - closer control points
          const tangentLength = 0.15;
          cp1X = current.x + Math.cos(currentAngle + Math.PI/2) * tangentLength * 50;
          cp1Y = current.y + Math.sin(currentAngle + Math.PI/2) * tangentLength * 50;
          cp2X = next.x - Math.cos(nextAngle + Math.PI/2) * tangentLength * 50;
          cp2Y = next.y - Math.sin(nextAngle + Math.PI/2) * tangentLength * 50;
        } else if (spiralVariation === 1) {
          // Loose spiral curves - wider control points
          const tangentLength = 0.4;
          cp1X = current.x + Math.cos(currentAngle) * tangentLength * 80;
          cp1Y = current.y + Math.sin(currentAngle) * tangentLength * 80;
          cp2X = next.x - Math.cos(nextAngle) * tangentLength * 80;
          cp2Y = next.y - Math.sin(nextAngle) * tangentLength * 80;
        } else {
          // Mixed tangent approach - asymmetric control
          cp1X = current.x + (next.x - current.x) * 0.3;
          cp1Y = current.y + (next.y - current.y) * 0.1;
          cp2X = current.x + (next.x - current.x) * 0.9;
          cp2Y = current.y + (next.y - current.y) * 0.7;
        }
        
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateDiagonalPattern(eventCount, virtualWidth, virtualHeight) {
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const x = virtualWidth * 0.1 + progress * virtualWidth * 0.8;
        const y = virtualHeight * 0.2 + progress * virtualHeight * 0.6;
        
        newMilestones.push({ x, y });
        newSlides.push({ 
          x: x,
          y: y - 150  // Bottom-left corner aligned with dot (slide height is ~150px)
        });
      }
      
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const cp1X = current.x + (next.x - current.x) * 0.3;
        const cp1Y = current.y + (next.y - current.y) * 0.3;
        const cp2X = current.x + (next.x - current.x) * 0.7;
        const cp2Y = current.y + (next.y - current.y) * 0.7;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    // New Creative Timeline Patterns

    function generateDNAHelixPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth / 2;
      const amplitude = Math.min(virtualWidth, virtualHeight) * 0.15;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const angle = progress * Math.PI * 4; // 4 full rotations
        
        // Create DNA helix with two intertwined spirals
        const helixRadius = amplitude * (0.5 + 0.5 * Math.sin(angle * 2));
        const x = centerX + helixRadius * Math.cos(angle);
        const y = virtualHeight * 0.1 + progress * virtualHeight * 0.8;
        
        newMilestones.push({ x, y });
        newSlides.push({ x, y: y - 150 });
      }
      
      // Create smooth curved path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const cp1X = current.x + (next.x - current.x) * 0.3;
        const cp1Y = current.y + (next.y - current.y) * 0.3;
        const cp2X = current.x + (next.x - current.x) * 0.7;
        const cp2Y = current.y + (next.y - current.y) * 0.7;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateInfinityPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth / 2;
      const centerY = virtualHeight / 2;
      const scaleX = virtualWidth * 0.3;
      const scaleY = virtualHeight * 0.25;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const t = (i / (eventCount - 1)) * 4 * Math.PI; // Full infinity loop
        
        // Parametric equations for infinity symbol (lemniscate)
        const cos_t = Math.cos(t);
        const sin_t = Math.sin(t);
        const denominator = 1 + sin_t * sin_t;
        
        const x = centerX + (scaleX * cos_t) / denominator;
        const y = centerY + (scaleY * sin_t * cos_t) / denominator;
        
        newMilestones.push({ x, y });
        newSlides.push({ x, y: y - 150 });
      }
      
      // Create smooth curved path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const cp1X = current.x + (next.x - current.x) * 0.4;
        const cp1Y = current.y + (next.y - current.y) * 0.4;
        const cp2X = current.x + (next.x - current.x) * 0.6;
        const cp2Y = current.y + (next.y - current.y) * 0.6;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateChevronPattern(eventCount, virtualWidth, virtualHeight) {
      const newMilestones = [];
      const newSlides = [];
      const chevronHeight = virtualHeight * 0.15;
      const startY = virtualHeight * 0.2;
      
      for (let i = 0; i < eventCount; i++) {
        const segmentProgress = i / (eventCount - 1);
        const chevronCount = Math.floor(segmentProgress * 4); // 4 chevron peaks
        const withinChevron = (segmentProgress * 4) % 1;
        
        let x, y;
        
        if (withinChevron <= 0.5) {
          // Going up the chevron
          x = virtualWidth * 0.1 + segmentProgress * virtualWidth * 0.8;
          y = startY + chevronCount * chevronHeight + withinChevron * 2 * chevronHeight;
        } else {
          // Going down the chevron
          x = virtualWidth * 0.1 + segmentProgress * virtualWidth * 0.8;
          y = startY + chevronCount * chevronHeight + (2 - withinChevron * 2) * chevronHeight;
        }
        
        newMilestones.push({ x, y });
        newSlides.push({ x, y: y - 150 });
      }
      
      // Create angular path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const next = newMilestones[i + 1];
        pathDefinition += ` L ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateFigureEightPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth / 2;
      const centerY = virtualHeight / 2;
      const radiusX = virtualWidth * 0.25;
      const radiusY = virtualHeight * 0.3;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const t = (i / (eventCount - 1)) * 2 * Math.PI;
        
        // Figure-8 parametric equations
        const x = centerX + radiusX * Math.sin(t);
        const y = centerY + radiusY * Math.sin(t) * Math.cos(t);
        
        newMilestones.push({ x, y });
        newSlides.push({ x, y: y - 150 });
      }
      
      // Create smooth curved path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const cp1X = current.x + (next.x - current.x) * 0.3;
        const cp1Y = current.y + (next.y - current.y) * 0.3;
        const cp2X = current.x + (next.x - current.x) * 0.7;
        const cp2Y = current.y + (next.y - current.y) * 0.7;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateSinusoidalPattern(eventCount, virtualWidth, virtualHeight) {
      const newMilestones = [];
      const newSlides = [];
      const amplitude = virtualHeight * 0.2;
      const frequency = 3; // Number of complete waves
      const centerY = virtualHeight / 2;
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const x = virtualWidth * 0.1 + progress * virtualWidth * 0.8;
        const y = centerY + amplitude * Math.sin(progress * frequency * 2 * Math.PI);
        
        newMilestones.push({ x, y });
        newSlides.push({ x, y: y - 150 });
      }
      
      // Create smooth sinusoidal path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const cp1X = current.x + (next.x - current.x) * 0.25;
        const cp1Y = current.y;
        const cp2X = current.x + (next.x - current.x) * 0.75;
        const cp2Y = next.y;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateGoldenSpiralPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth / 2;
      const centerY = virtualHeight / 2;
      const goldenRatio = 1.618033988749;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const angle = progress * 4 * Math.PI; // 4 rotations
        const radius = Math.min(virtualWidth, virtualHeight) * 0.3 * Math.pow(goldenRatio, progress * 2 - 1);
        
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);
        
        newMilestones.push({ x, y });
        newSlides.push({ x, y: y - 150 });
      }
      
      // Create smooth spiral path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const cp1X = current.x + (next.x - current.x) * 0.3;
        const cp1Y = current.y + (next.y - current.y) * 0.3;
        const cp2X = current.x + (next.x - current.x) * 0.7;
        const cp2Y = current.y + (next.y - current.y) * 0.7;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateAccordionPattern(eventCount, virtualWidth, virtualHeight) {
      const newMilestones = [];
      const newSlides = [];
      const foldWidth = virtualWidth * 0.15;
      const foldHeight = virtualHeight * 0.8 / Math.ceil(eventCount / 2);
      
      for (let i = 0; i < eventCount; i++) {
        const row = Math.floor(i / 2);
        const isEvenRow = row % 2 === 0;
        const isLeftSide = i % 2 === 0;
        
        let x, y;
        
        if (isEvenRow) {
          // Even rows: left to right
          x = virtualWidth * 0.1 + (isLeftSide ? 0 : foldWidth);
        } else {
          // Odd rows: right to left
          x = virtualWidth * 0.9 - (isLeftSide ? 0 : foldWidth);
        }
        
        y = virtualHeight * 0.1 + row * foldHeight + foldHeight * 0.5;
        
        newMilestones.push({ x, y });
        newSlides.push({ x, y: y - 150 });
      }
      
      // Create accordion-style path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 1; i < newMilestones.length; i++) {
        const prev = newMilestones[i - 1];
        const curr = newMilestones[i];
        
        // Create accordion folds
        if (i % 2 === 1) {
          // Going to the fold
          pathDefinition += ` L ${curr.x} ${curr.y}`;
        } else {
          // Coming back from the fold
          const midY = (prev.y + curr.y) / 2;
          pathDefinition += ` L ${prev.x} ${midY} L ${curr.x} ${midY} L ${curr.x} ${curr.y}`;
        }
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    // Professional Timeline Layout Patterns

    function generateAlternatingLeftRightPattern(eventCount, virtualWidth, virtualHeight) {
      console.log('GENERATING ALTERNATING LEFT RIGHT PATTERN - SLIDES TO RIGHT OF DOTS');
      const centerX = virtualWidth / 2;
      const verticalSpacing = virtualHeight * 0.8 / (eventCount - 1);
      const horizontalOffset = 300; // Distance from center line
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const y = virtualHeight * 0.1 + i * verticalSpacing;
        const x = centerX; // All milestones on center line
        
        newMilestones.push({ x, y });
        
        // Place all slides to the right of each dot with proper spacing
        const slideX = x + 300; // Position slide 300px to the right of the dot to ensure no overlap
        newSlides.push({ x: slideX, y: y - 75 });
      }
      
      // Create straight vertical path down the center
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 1; i < newMilestones.length; i++) {
        pathDefinition += ` L ${newMilestones[i].x} ${newMilestones[i].y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateSteppedTimelinePattern(eventCount, virtualWidth, virtualHeight) {
      const stepWidth = virtualWidth * 0.7 / eventCount;
      const stepHeight = 100;
      const startX = virtualWidth * 0.15;
      const startY = virtualHeight * 0.7;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const x = startX + i * stepWidth;
        const y = startY - (i % 2) * stepHeight; // Alternate high/low steps
        
        newMilestones.push({ x, y });
        
        // Position slides above the steps
        const slideY = y - 200;
        newSlides.push({ x: x - 120, y: slideY });
      }
      
      // Create stepped path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 1; i < newMilestones.length; i++) {
        const prev = newMilestones[i - 1];
        const curr = newMilestones[i];
        // Create step-like path with right angles
        const midX = (prev.x + curr.x) / 2;
        pathDefinition += ` L ${midX} ${prev.y} L ${midX} ${curr.y} L ${curr.x} ${curr.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateCurvedCenterlinePattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth / 2;
      const newMilestones = [];
      const newSlides = [];
      const curveAmplitude = virtualWidth * 0.4; // Maximum amplitude - 40% of canvas width
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const y = virtualHeight * 0.02 + progress * virtualHeight * 0.96; // Use 96% of vertical space
        
        // Create wide S-curve that spans most of the canvas width
        const curveOffset = Math.sin(progress * Math.PI * 1.5) * curveAmplitude;
        const x = centerX + curveOffset;
        
        newMilestones.push({ x, y });
        
        // Position slides alternately on opposite sides of curve
        const isLeft = (curveOffset > 0) !== (i % 2 === 0); // Smart alternation based on curve
        const slideX = isLeft ? x - 350 : x + 110;
        newSlides.push({ x: slideX, y: y - 75 });
      }
      
      // Create smooth curved path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 1; i < newMilestones.length; i++) {
        const prev = newMilestones[i - 1];
        const curr = newMilestones[i];
        const cp1X = prev.x;
        const cp1Y = prev.y + (curr.y - prev.y) * 0.5;
        const cp2X = curr.x;
        const cp2Y = curr.y - (curr.y - prev.y) * 0.5;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${curr.x} ${curr.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateVerticalBranchPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth * 0.2; // Main trunk on left side
      const branchLength = 200;
      const verticalSpacing = virtualHeight * 0.8 / (eventCount - 1);
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const y = virtualHeight * 0.1 + i * verticalSpacing;
        
        // Trunk milestone
        const trunkX = centerX;
        
        // Branch extends right from trunk
        const branchX = trunkX + branchLength;
        newMilestones.push({ x: branchX, y });
        
        // Position slide at end of branch
        newSlides.push({ x: branchX + 20, y: y - 75 });
      }
      
      // Create branching path - vertical trunk with horizontal branches
      let pathDefinition = `M ${centerX} ${virtualHeight * 0.1}`;
      pathDefinition += ` L ${centerX} ${virtualHeight * 0.9}`; // Main trunk
      
      // Add branches
      for (let i = 0; i < newMilestones.length; i++) {
        const milestone = newMilestones[i];
        pathDefinition += ` M ${centerX} ${milestone.y} L ${milestone.x} ${milestone.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateHorizontalBranchPattern(eventCount, virtualWidth, virtualHeight) {
      const centerY = virtualHeight / 2; // Main trunk horizontally centered
      const branchLength = 150;
      const horizontalSpacing = virtualWidth * 0.7 / (eventCount - 1);
      const startX = virtualWidth * 0.15;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const x = startX + i * horizontalSpacing;
        
        // Alternate branches above and below trunk
        const isAbove = i % 2 === 0;
        const branchY = isAbove ? centerY - branchLength : centerY + branchLength;
        newMilestones.push({ x, y: branchY });
        
        // Position slide near branch end
        const slideY = isAbove ? branchY - 150 : branchY + 20;
        newSlides.push({ x: x - 120, y: slideY });
      }
      
      // Create branching path - horizontal trunk with vertical branches
      let pathDefinition = `M ${startX} ${centerY} L ${startX + (eventCount - 1) * horizontalSpacing} ${centerY}`;
      
      // Add branches
      for (let i = 0; i < newMilestones.length; i++) {
        const milestone = newMilestones[i];
        const x = startX + i * horizontalSpacing;
        pathDefinition += ` M ${x} ${centerY} L ${milestone.x} ${milestone.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateDiagonalStepsPattern(eventCount, virtualWidth, virtualHeight) {
      const startX = virtualWidth * 0.1;
      const startY = virtualHeight * 0.1;
      const endX = virtualWidth * 0.9;
      const endY = virtualHeight * 0.9;
      const stepSize = 80;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const baseX = startX + progress * (endX - startX);
        const baseY = startY + progress * (endY - startY);
        
        // Add step offset
        const stepOffset = (i % 2) * stepSize;
        const x = baseX + stepOffset;
        const y = baseY - stepOffset;
        
        newMilestones.push({ x, y });
        
        // Position slides to the side of steps
        const slideX = x + (i % 2 === 0 ? 20 : -260);
        newSlides.push({ x: slideX, y: y - 75 });
      }
      
      // Create diagonal stepped path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 1; i < newMilestones.length; i++) {
        const prev = newMilestones[i - 1];
        const curr = newMilestones[i];
        // Create diagonal steps
        const midX = (prev.x + curr.x) / 2;
        const midY = (prev.y + curr.y) / 2;
        pathDefinition += ` L ${midX} ${prev.y} L ${midX} ${midY} L ${curr.x} ${curr.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateCircularBranchPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth / 2;
      const centerY = virtualHeight / 2;
      const radius = Math.min(virtualWidth, virtualHeight) * 0.25;
      const branchLength = 120;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const angle = (i / eventCount) * 2 * Math.PI - Math.PI / 2; // Start from top
        
        // Hub position (on circle)
        const hubX = centerX + radius * Math.cos(angle);
        const hubY = centerY + radius * Math.sin(angle);
        
        // Branch extends outward from hub
        const branchX = hubX + branchLength * Math.cos(angle);
        const branchY = hubY + branchLength * Math.sin(angle);
        
        newMilestones.push({ x: branchX, y: branchY });
        
        // Position slide further out on branch
        const slideDistance = branchLength + 40;
        const slideX = hubX + slideDistance * Math.cos(angle) - 120;
        const slideY = hubY + slideDistance * Math.sin(angle) - 75;
        newSlides.push({ x: slideX, y: slideY });
      }
      
      // Create circular hub with radiating branches
      let pathDefinition = '';
      for (let i = 0; i < newMilestones.length; i++) {
        const angle = (i / eventCount) * 2 * Math.PI - Math.PI / 2;
        const hubX = centerX + radius * Math.cos(angle);
        const hubY = centerY + radius * Math.sin(angle);
        const milestone = newMilestones[i];
        
        if (i === 0) {
          pathDefinition = `M ${hubX} ${hubY}`;
        }
        pathDefinition += ` M ${hubX} ${hubY} L ${milestone.x} ${milestone.y}`;
      }
      
      // Add circular hub
      pathDefinition += ` M ${centerX + radius} ${centerY}`;
      pathDefinition += ` A ${radius} ${radius} 0 1 1 ${centerX - radius} ${centerY}`;
      pathDefinition += ` A ${radius} ${radius} 0 1 1 ${centerX + radius} ${centerY}`;
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateSConnectorPattern(eventCount, virtualWidth, virtualHeight) {
      const newMilestones = [];
      const newSlides = [];
      const amplitude = virtualWidth * 0.15;
      const centerX = virtualWidth / 2;
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const y = virtualHeight * 0.1 + progress * virtualHeight * 0.8;
        
        // Create flowing S-curve
        const sValue = Math.sin(progress * Math.PI * 1.5) * amplitude;
        const x = centerX + sValue;
        
        newMilestones.push({ x, y });
        
        // Position slides away from curve direction
        const isLeft = sValue < 0;
        const slideX = isLeft ? x - 350 : x + 110;
        newSlides.push({ x: slideX, y: y - 75 });
      }
      
      // Create smooth S-curve path with connectors to slides
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 1; i < newMilestones.length; i++) {
        const prev = newMilestones[i - 1];
        const curr = newMilestones[i];
        
        // Smooth S-curve
        const cp1X = prev.x;
        const cp1Y = prev.y + (curr.y - prev.y) * 0.6;
        const cp2X = curr.x;
        const cp2Y = curr.y - (curr.y - prev.y) * 0.6;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${curr.x} ${curr.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateMilestoneRoadPattern(eventCount, virtualWidth, virtualHeight) {
      const roadWidth = 100;
      const centerY = virtualHeight / 2;
      const spacing = virtualWidth * 0.8 / (eventCount - 1);
      const startX = virtualWidth * 0.1;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const x = startX + i * spacing;
        
        // Road curves gently up and down
        const curveOffset = Math.sin((i / eventCount) * Math.PI * 3) * 50;
        const y = centerY + curveOffset;
        
        newMilestones.push({ x, y });
        
        // Alternate slides above and below road
        const isAbove = i % 2 === 0;
        const slideY = isAbove ? y - 200 : y + 50;
        newSlides.push({ x: x - 120, y: slideY });
      }
      
      // Create road-like path with gentle curves
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 1; i < newMilestones.length; i++) {
        const prev = newMilestones[i - 1];
        const curr = newMilestones[i];
        const cp1X = prev.x + (curr.x - prev.x) * 0.4;
        const cp1Y = prev.y;
        const cp2X = curr.x - (curr.x - prev.x) * 0.4;
        const cp2Y = curr.y;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${curr.x} ${curr.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateFlowingRiverPattern(eventCount, virtualWidth, virtualHeight) {
      const newMilestones = [];
      const newSlides = [];
      const riverWidth = virtualWidth * 0.9; // Use 90% of canvas width
      const startX = virtualWidth * 0.05; // Start from 5% edge
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const y = virtualHeight * 0.02 + progress * virtualHeight * 0.96; // Use 96% of height
        
        // Create wider meandering river path that spans the full canvas
        const meander1 = Math.sin(progress * Math.PI * 1.8) * riverWidth * 0.4; // Maximum amplitude
        const meander2 = Math.sin(progress * Math.PI * 2.7 + 1.2) * riverWidth * 0.2; // Secondary meander
        const x = startX + riverWidth * 0.5 + meander1 + meander2;
        
        newMilestones.push({ x, y });
        
        // Position slides on river banks with more spacing
        const bankSide = meander1 > 0 ? -1 : 1; // Opposite side of curve
        const slideX = x + bankSide * 200 + (bankSide < 0 ? -240 : 0);
        newSlides.push({ x: slideX, y: y - 75 });
      }
      
      // Create flowing river path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 1; i < newMilestones.length; i++) {
        const prev = newMilestones[i - 1];
        const curr = newMilestones[i];
        
        // Create natural river-like curves
        const distance = Math.sqrt(Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2));
        const tension = Math.min(distance * 0.3, 80);
        
        const cp1X = prev.x + (curr.x - prev.x) * 0.2;
        const cp1Y = prev.y + tension;
        const cp2X = curr.x - (curr.x - prev.x) * 0.2;
        const cp2Y = curr.y - tension;
        
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${curr.x} ${curr.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    // Advanced Curve Variation Patterns

    function generateLoopingRibbonPattern(eventCount, virtualWidth, virtualHeight) {
      const newMilestones = [];
      const newSlides = [];
      const amplitude = virtualHeight * 0.2;
      const centerY = virtualHeight / 2;
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const x = virtualWidth * 0.1 + progress * virtualWidth * 0.8;
        
        // Create multiple overlapping sine waves for complex ribbon effect
        const wave1 = Math.sin(progress * 2 * Math.PI) * amplitude * 0.6;
        const wave2 = Math.sin(progress * 3 * Math.PI + Math.PI/4) * amplitude * 0.3;
        const wave3 = Math.sin(progress * 5 * Math.PI + Math.PI/2) * amplitude * 0.2;
        const y = centerY + wave1 + wave2 + wave3;
        
        newMilestones.push({ x, y });
        newSlides.push({ x, y: y - 150 });
      }
      
      // Variable tangent lengths and directions for ribbon-like flow
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const progress = i / (eventCount - 1);
        
        // Calculate dynamic tangent direction based on local curve direction
        const prevPoint = i > 0 ? newMilestones[i - 1] : current;
        const nextNextPoint = i < newMilestones.length - 2 ? newMilestones[i + 2] : next;
        
        // Smooth directional tangents
        const incomingAngle = Math.atan2(current.y - prevPoint.y, current.x - prevPoint.x);
        const outgoingAngle = Math.atan2(nextNextPoint.y - next.y, nextNextPoint.x - next.x);
        
        const tangentLength = 60 + Math.sin(progress * 4 * Math.PI) * 20; // Variable length
        
        const cp1X = current.x + Math.cos(incomingAngle) * tangentLength;
        const cp1Y = current.y + Math.sin(incomingAngle) * tangentLength;
        const cp2X = next.x - Math.cos(outgoingAngle) * tangentLength;
        const cp2Y = next.y - Math.sin(outgoingAngle) * tangentLength;
        
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateElasticBouncePattern(eventCount, virtualWidth, virtualHeight) {
      const newMilestones = [];
      const newSlides = [];
      const baseY = virtualHeight * 0.6;
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const x = virtualWidth * 0.1 + progress * virtualWidth * 0.8;
        
        // Elastic bounce effect with varying amplitude
        const bounceFreq = 8;
        const decay = Math.exp(-progress * 3); // Exponential decay
        const bounce = Math.sin(progress * bounceFreq * Math.PI) * virtualHeight * 0.25 * decay;
        const y = baseY + bounce;
        
        newMilestones.push({ x, y });
        newSlides.push({ x, y: y - 150 });
      }
      
      // Dynamic control points that create elastic spring-like curves
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const progress = i / (eventCount - 1);
        
        // Calculate spring tension effect
        const springTension = 1 + Math.sin(progress * 8 * Math.PI) * 0.5;
        const dampening = Math.exp(-progress * 2);
        
        // Variable control point distances based on spring physics
        const cp1Distance = 40 * springTension * dampening;
        const cp2Distance = 30 * springTension * dampening;
        
        // Perpendicular tangents for spring effect
        const direction = Math.atan2(next.y - current.y, next.x - current.x);
        const perpendicular = direction + Math.PI/2;
        
        const cp1X = current.x + Math.cos(direction) * cp1Distance;
        const cp1Y = current.y + Math.sin(direction) * cp1Distance + Math.cos(perpendicular) * 20;
        const cp2X = next.x - Math.cos(direction) * cp2Distance;
        const cp2Y = next.y - Math.sin(direction) * cp2Distance + Math.cos(perpendicular) * -15;
        
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateTurbulentFlowPattern(eventCount, virtualWidth, virtualHeight) {
      const newMilestones = [];
      const newSlides = [];
      const centerY = virtualHeight / 2;
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const x = virtualWidth * 0.1 + progress * virtualWidth * 0.8;
        
        // Create turbulent flow with multiple frequency components
        const turbulence1 = Math.sin(progress * 7 * Math.PI) * virtualHeight * 0.1;
        const turbulence2 = Math.sin(progress * 13 * Math.PI + 1.5) * virtualHeight * 0.06;
        const turbulence3 = Math.sin(progress * 19 * Math.PI + 2.8) * virtualHeight * 0.04;
        const mainFlow = Math.sin(progress * 2 * Math.PI) * virtualHeight * 0.15;
        
        const y = centerY + mainFlow + turbulence1 + turbulence2 + turbulence3;
        
        newMilestones.push({ x, y });
        newSlides.push({ x, y: y - 150 });
      }
      
      // Chaotic but smooth control points for turbulent effect
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const progress = i / (eventCount - 1);
        
        // Random-ish but deterministic control point variations
        const chaos1 = Math.sin(progress * 11 * Math.PI + 0.7) * 0.3;
        const chaos2 = Math.sin(progress * 17 * Math.PI + 1.9) * 0.4;
        
        // Varying control point distances and angles
        const baseDistance = (next.x - current.x) * 0.4;
        const cp1Distance = baseDistance * (1 + chaos1);
        const cp2Distance = baseDistance * (1 + chaos2);
        
        const cp1Angle = Math.atan2(next.y - current.y, next.x - current.x) + chaos1;
        const cp2Angle = Math.atan2(next.y - current.y, next.x - current.x) + chaos2;
        
        const cp1X = current.x + Math.cos(cp1Angle) * cp1Distance;
        const cp1Y = current.y + Math.sin(cp1Angle) * cp1Distance;
        const cp2X = next.x - Math.cos(cp2Angle) * cp2Distance;
        const cp2Y = next.y - Math.sin(cp2Angle) * cp2Distance;
        
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateCompanyMilestoneCurvePattern(eventCount, virtualWidth, virtualHeight) {
      const newMilestones = [];
      const newSlides = [];
      
      // Create a smooth, professional curved path that flows elegantly across the canvas
      const startX = virtualWidth * 0.1;
      const endX = virtualWidth * 0.9;
      const pathWidth = endX - startX;
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        
        // Smooth S-curve that flows naturally from left to right
        const x = startX + progress * pathWidth;
        
        // Create an elegant curve with gentle waves - similar to Alamy reference
        const primaryCurve = Math.sin(progress * Math.PI * 1.2) * virtualHeight * 0.25;
        const secondaryCurve = Math.sin(progress * Math.PI * 2.5 + Math.PI/4) * virtualHeight * 0.08;
        const baseY = virtualHeight * 0.5;
        const y = baseY + primaryCurve + secondaryCurve;
        
        newMilestones.push({ x, y });
        
        // Position slides alternately above and below the curve for balance
        const curveDirection = primaryCurve > 0 ? -1 : 1; // Opposite side of curve
        const slideOffsetY = curveDirection * 200; // Distance from curve
        const slideX = x + (curveDirection > 0 ? -250 : 20); // Offset to avoid overlap
        
        newSlides.push({ 
          x: slideX, 
          y: y + slideOffsetY - (curveDirection > 0 ? 150 : 0) 
        });
      }
      
      // Create smooth, professional curves between milestones - thick marker style
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        
        // Calculate curve direction for natural flow
        const deltaX = next.x - current.x;
        const deltaY = next.y - current.y;
        
        // Control points that create smooth, natural curves
        const controlDistance = deltaX * 0.4;
        
        // First control point - extends from current point
        const cp1X = current.x + controlDistance;
        const cp1Y = current.y;
        
        // Second control point - approaches next point
        const cp2X = next.x - controlDistance;
        const cp2Y = next.y;
        
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateDiamondRhombusPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth * 0.5;
      const centerY = virtualHeight * 0.5;
      const diamondWidth = virtualWidth * 0.35;
      const diamondHeight = virtualHeight * 0.4;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        
        // Create diamond/rhombus shape by mapping progress to diamond perimeter
        let x, y;
        
        if (progress <= 0.25) {
          // Top-right edge of diamond
          const t = progress * 4; // 0 to 1
          x = centerX + t * diamondWidth;
          y = centerY - (1 - t) * diamondHeight;
        } else if (progress <= 0.5) {
          // Bottom-right edge of diamond
          const t = (progress - 0.25) * 4; // 0 to 1
          x = centerX + (1 - t) * diamondWidth;
          y = centerY + t * diamondHeight;
        } else if (progress <= 0.75) {
          // Bottom-left edge of diamond
          const t = (progress - 0.5) * 4; // 0 to 1
          x = centerX - t * diamondWidth;
          y = centerY + (1 - t) * diamondHeight;
        } else {
          // Top-left edge of diamond
          const t = (progress - 0.75) * 4; // 0 to 1
          x = centerX - (1 - t) * diamondWidth;
          y = centerY - t * diamondHeight;
        }
        
        newMilestones.push({ x, y });
        
        // Position slides outside the diamond with outward offset
        const offsetDistance = 150;
        const angleToCenter = Math.atan2(centerY - y, centerX - x);
        const slideX = x + Math.cos(angleToCenter) * offsetDistance;
        const slideY = y + Math.sin(angleToCenter) * offsetDistance - 75;
        
        newSlides.push({ x: slideX, y: slideY });
      }
      
      // Create smooth diamond path with curved corners
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      
      for (let i = 0; i < newMilestones.length; i++) {
        const current = newMilestones[i];
        const next = newMilestones[(i + 1) % newMilestones.length];
        
        // Create smooth curves at diamond corners
        const controlDistance = 40;
        const currentProgress = i / (eventCount - 1);
        const nextProgress = ((i + 1) % eventCount) / (eventCount - 1);
        
        // Determine if we're at a corner (quarter points)
        const isCorner = Math.abs(currentProgress % 0.25) < 0.1 || Math.abs(nextProgress % 0.25) < 0.1;
        const curveStrength = isCorner ? controlDistance * 1.5 : controlDistance * 0.5;
        
        const cp1X = current.x + (next.x - current.x) * 0.3;
        const cp1Y = current.y + (next.y - current.y) * 0.3;
        const cp2X = current.x + (next.x - current.x) * 0.7;
        const cp2Y = current.y + (next.y - current.y) * 0.7;
        
        if (i === newMilestones.length - 1) {
          // Close the diamond shape
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${newMilestones[0].x} ${newMilestones[0].y}`;
        } else {
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
        }
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateHeartTeardropPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth * 0.5;
      const centerY = virtualHeight * 0.5;
      const scaleX = virtualWidth * 0.25;
      const scaleY = virtualHeight * 0.3;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        // Map progress from 0 to 2œÄ for heart parametric equations
        const t = progress * 2 * Math.PI;
        
        // Heart/teardrop parametric equations (cardioid)
        // x = a * (2*cos(t) - cos(2*t))
        // y = a * (2*sin(t) - sin(2*t))
        const heartX = scaleX * (2 * Math.cos(t) - Math.cos(2 * t));
        const heartY = scaleY * (2 * Math.sin(t) - Math.sin(2 * t));
        
        // Flip vertically so the point is at the bottom (like your drawing)
        const x = centerX + heartX;
        const y = centerY - heartY + scaleY * 0.5; // Offset to center properly
        
        newMilestones.push({ x, y });
        
        // Position slides outside the heart shape
        const offsetDistance = 120;
        // Calculate outward direction from heart center
        const angleFromCenter = Math.atan2(y - centerY, x - centerX);
        const slideX = x + Math.cos(angleFromCenter) * offsetDistance;
        const slideY = y + Math.sin(angleFromCenter) * offsetDistance - 75;
        
        newSlides.push({ x: slideX, y: slideY });
      }
      
      // Create smooth heart-shaped path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      
      for (let i = 0; i < newMilestones.length; i++) {
        const current = newMilestones[i];
        const next = newMilestones[(i + 1) % newMilestones.length];
        
        // Calculate tangent direction for smooth heart curves
        const currentProgress = i / (eventCount - 1);
        const t = currentProgress * 2 * Math.PI;
        
        // Tangent vector for heart shape
        const tangentX = scaleX * (-2 * Math.sin(t) + 2 * Math.sin(2 * t));
        const tangentY = -scaleY * (2 * Math.cos(t) - 2 * Math.cos(2 * t)); // Flipped
        
        // Normalize tangent and create control points
        const tangentLength = Math.sqrt(tangentX * tangentX + tangentY * tangentY);
        const normalizedTangentX = tangentX / tangentLength;
        const normalizedTangentY = tangentY / tangentLength;
        
        const controlDistance = 30;
        const cp1X = current.x + normalizedTangentX * controlDistance;
        const cp1Y = current.y + normalizedTangentY * controlDistance;
        const cp2X = next.x - normalizedTangentX * controlDistance;
        const cp2Y = next.y - normalizedTangentY * controlDistance;
        
        if (i === newMilestones.length - 1) {
          // Close the heart shape
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${newMilestones[0].x} ${newMilestones[0].y}`;
        } else {
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
        }
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateStarAsteriskPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth * 0.5;
      const centerY = virtualHeight * 0.5;
      const outerRadius = Math.min(virtualWidth, virtualHeight) * 0.35;
      const innerRadius = outerRadius * 0.4;
      const numPoints = 8; // 8-pointed star like your drawing
      const newMilestones = [];
      const newSlides = [];
      
      // Create star points by alternating between outer and inner radius
      const starPoints = [];
      for (let i = 0; i < numPoints * 2; i++) {
        const angle = (i * Math.PI) / numPoints - Math.PI / 2; // Start from top
        const radius = i % 2 === 0 ? outerRadius : innerRadius;
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);
        starPoints.push({ x, y });
      }
      
      // Distribute timeline events around the star perimeter
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const totalPerimeter = starPoints.length;
        const position = progress * (totalPerimeter - 1);
        const segmentIndex = Math.floor(position);
        const segmentProgress = position - segmentIndex;
        
        // Interpolate between star points
        const currentPoint = starPoints[segmentIndex];
        const nextPoint = starPoints[(segmentIndex + 1) % starPoints.length];
        
        const x = currentPoint.x + (nextPoint.x - currentPoint.x) * segmentProgress;
        const y = currentPoint.y + (nextPoint.y - currentPoint.y) * segmentProgress;
        
        newMilestones.push({ x, y });
        
        // Position slides at the tips of star points (outward direction)
        const slideDistance = 140;
        const angleFromCenter = Math.atan2(y - centerY, x - centerX);
        const slideX = x + Math.cos(angleFromCenter) * slideDistance;
        const slideY = y + Math.sin(angleFromCenter) * slideDistance - 75;
        
        newSlides.push({ x: slideX, y: slideY });
      }
      
      // Create star path with sharp points and smooth curves
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      
      for (let i = 0; i < newMilestones.length; i++) {
        const current = newMilestones[i];
        const next = newMilestones[(i + 1) % newMilestones.length];
        
        // Determine if we're at a star point (outer radius) or valley (inner radius)
        const currentDistance = Math.sqrt(Math.pow(current.x - centerX, 2) + Math.pow(current.y - centerY, 2));
        const nextDistance = Math.sqrt(Math.pow(next.x - centerX, 2) + Math.pow(next.y - centerY, 2));
        
        const isCurrentOuter = currentDistance > (outerRadius + innerRadius) / 2;
        const isNextOuter = nextDistance > (outerRadius + innerRadius) / 2;
        
        // Create sharp points at star tips, smooth curves elsewhere
        let controlDistance;
        if (isCurrentOuter || isNextOuter) {
          controlDistance = 15; // Sharp points at star tips
        } else {
          controlDistance = 35; // Smooth curves in valleys
        }
        
        const cp1X = current.x + (next.x - current.x) * 0.2;
        const cp1Y = current.y + (next.y - current.y) * 0.2;
        const cp2X = current.x + (next.x - current.x) * 0.8;
        const cp2Y = current.y + (next.y - current.y) * 0.8;
        
        if (i === newMilestones.length - 1) {
          // Close the star shape
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${newMilestones[0].x} ${newMilestones[0].y}`;
        } else {
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
        }
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateCloudOrganicPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth * 0.5;
      const centerY = virtualHeight * 0.5;
      const baseRadius = Math.min(virtualWidth, virtualHeight) * 0.25;
      const newMilestones = [];
      const newSlides = [];
      
      // Create organic cloud-like shape with varying radius
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const angle = progress * 2 * Math.PI;
        
        // Create organic bulges and indentations like your cloud drawing
        const bulge1 = Math.sin(angle * 3) * 0.3; // Primary bulges
        const bulge2 = Math.sin(angle * 5 + 1.2) * 0.15; // Secondary variation
        const bulge3 = Math.sin(angle * 7 + 2.4) * 0.08; // Fine detail
        const noise = Math.sin(angle * 11 + 3.6) * 0.05; // Organic noise
        
        // Combine variations for natural cloud-like outline
        const radiusVariation = 1 + bulge1 + bulge2 + bulge3 + noise;
        const radius = baseRadius * radiusVariation;
        
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);
        
        newMilestones.push({ x, y });
        
        // Position slides outside the cloud with organic spacing
        const slideDistance = 130 + Math.abs(bulge1) * 40; // Variable distance based on bulge
        const slideX = x + Math.cos(angle) * slideDistance;
        const slideY = y + Math.sin(angle) * slideDistance - 75;
        
        newSlides.push({ x: slideX, y: slideY });
      }
      
      // Create smooth, flowing cloud path with organic curves
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      
      for (let i = 0; i < newMilestones.length; i++) {
        const current = newMilestones[i];
        const next = newMilestones[(i + 1) % newMilestones.length];
        
        // Calculate organic curve strength based on radius variations
        const currentProgress = i / (eventCount - 1);
        const nextProgress = ((i + 1) % eventCount) / (eventCount - 1);
        
        const currentAngle = currentProgress * 2 * Math.PI;
        const nextAngle = nextProgress * 2 * Math.PI;
        
        // Vary control point distance for organic feel
        const currentBulge = Math.sin(currentAngle * 3) * 0.3;
        const nextBulge = Math.sin(nextAngle * 3) * 0.3;
        
        const controlDistance = 25 + Math.abs(currentBulge + nextBulge) * 20;
        
        // Create tangent directions that follow the cloud's organic flow
        const currentRadius = Math.sqrt(Math.pow(current.x - centerX, 2) + Math.pow(current.y - centerY, 2));
        const nextRadius = Math.sqrt(Math.pow(next.x - centerX, 2) + Math.pow(next.y - centerY, 2));
        
        // Tangent direction perpendicular to radius for smooth cloud curves
        const currentTangentAngle = currentAngle + Math.PI / 2;
        const nextTangentAngle = nextAngle + Math.PI / 2;
        
        const cp1X = current.x + Math.cos(currentTangentAngle) * controlDistance;
        const cp1Y = current.y + Math.sin(currentTangentAngle) * controlDistance;
        const cp2X = next.x - Math.cos(nextTangentAngle) * controlDistance;
        const cp2Y = next.y - Math.sin(nextTangentAngle) * controlDistance;
        
        if (i === newMilestones.length - 1) {
          // Close the cloud shape
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${newMilestones[0].x} ${newMilestones[0].y}`;
        } else {
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
        }
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateInfinityLoopPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth * 0.5;
      const centerY = virtualHeight * 0.5;
      const scaleX = virtualWidth * 0.3;
      const scaleY = virtualHeight * 0.2;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        // Map progress to infinity symbol parametric equations
        const t = progress * 4 * Math.PI; // Full infinity loop
        
        // Infinity symbol (lemniscate) parametric equations
        // x = a * cos(t) / (1 + sin¬≤(t))
        // y = a * sin(t) * cos(t) / (1 + sin¬≤(t))
        const sinT = Math.sin(t);
        const cosT = Math.cos(t);
        const denominator = 1 + sinT * sinT;
        
        const infinityX = scaleX * cosT / denominator;
        const infinityY = scaleY * sinT * cosT / denominator;
        
        const x = centerX + infinityX;
        const y = centerY + infinityY;
        
        newMilestones.push({ x, y });
        
        // Position slides outside the infinity loop
        const offsetDistance = 120;
        // Calculate outward direction based on current position on infinity curve
        let slideAngle;
        
        // Determine which loop we're on and position slides accordingly
        if (Math.abs(infinityX) > scaleX * 0.1) {
          // On the sides of the infinity - position slides outward
          slideAngle = infinityX > 0 ? 0 : Math.PI; // Right or left
        } else {
          // At the center crossing - position slides up or down
          slideAngle = infinityY > 0 ? Math.PI/2 : -Math.PI/2; // Up or down
        }
        
        const slideX = x + Math.cos(slideAngle) * offsetDistance;
        const slideY = y + Math.sin(slideAngle) * offsetDistance - 75;
        
        newSlides.push({ x: slideX, y: slideY });
      }
      
      // Create smooth infinity path with proper curve transitions
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      
      for (let i = 0; i < newMilestones.length; i++) {
        const current = newMilestones[i];
        const next = newMilestones[(i + 1) % newMilestones.length];
        
        // Calculate tangent direction for smooth infinity curves
        const currentProgress = i / (eventCount - 1);
        const t = currentProgress * 4 * Math.PI;
        
        // Derivative of infinity curve for tangent calculation
        const sinT = Math.sin(t);
        const cosT = Math.cos(t);
        const denominator = 1 + sinT * sinT;
        const denominatorSq = denominator * denominator;
        
        // Tangent vector components
        const tangentX = scaleX * (-sinT * denominator - cosT * 2 * sinT * cosT) / denominatorSq;
        const tangentY = scaleY * ((cosT * cosT - sinT * sinT) * denominator - sinT * cosT * 2 * sinT * cosT) / denominatorSq;
        
        // Normalize tangent and create control points
        const tangentLength = Math.sqrt(tangentX * tangentX + tangentY * tangentY) || 1;
        const normalizedTangentX = tangentX / tangentLength;
        const normalizedTangentY = tangentY / tangentLength;
        
        const controlDistance = 25;
        const cp1X = current.x + normalizedTangentX * controlDistance;
        const cp1Y = current.y + normalizedTangentY * controlDistance;
        const cp2X = next.x - normalizedTangentX * controlDistance;
        const cp2Y = next.y - normalizedTangentY * controlDistance;
        
        if (i === newMilestones.length - 1) {
          // Close the infinity shape
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${newMilestones[0].x} ${newMilestones[0].y}`;
        } else {
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
        }
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    // Collision Detection and Resolution with Milestone Association
    function resolveSlideOverlaps(slides, milestones) {
      const slideWidth = 240;
      const slideHeight = 150;
      const minGap = 20; // Minimum gap between slides
      const resolvedSlides = [...slides];
      
      // Multiple passes to resolve all overlaps
      let maxIterations = 10;
      let overlapsFound = true;
      
      while (overlapsFound && maxIterations > 0) {
        overlapsFound = false;
        
        // Check for overlaps and resolve them
        for (let i = 0; i < resolvedSlides.length; i++) {
          for (let j = i + 1; j < resolvedSlides.length; j++) {
            const slide1 = resolvedSlides[i];
            const slide2 = resolvedSlides[j];
            
            // Check if slides overlap
            if (slidesOverlap(slide1, slide2, slideWidth, slideHeight)) {
              overlapsFound = true;
              
              // Get corresponding milestones
              const milestone1 = milestones ? milestones[i] : null;
              const milestone2 = milestones ? milestones[j] : null;
              
              // Resolve overlap by moving both slides to maintain milestone association
              const newPositions = repositionSlidesWithMilestones(
                slide1, slide2, milestone1, milestone2, i, j, 
                slideWidth, slideHeight, minGap
              );
              
              resolvedSlides[i] = newPositions.slide1;
              resolvedSlides[j] = newPositions.slide2;
            }
          }
        }
        
        maxIterations--;
      }
      
      return resolvedSlides;
    }
    
    function slidesOverlap(slide1, slide2, width, height) {
      return !(slide1.x + width < slide2.x || 
               slide2.x + width < slide1.x || 
               slide1.y + height < slide2.y || 
               slide2.y + height < slide1.y);
    }
    
    function repositionSlidesWithMilestones(slide1, slide2, milestone1, milestone2, index1, index2, width, height, minGap) {
      const totalWidth = width + minGap;
      const totalHeight = height + minGap;
      
      // Calculate preferred positions relative to milestones
      const getPreferredPositions = (milestone, slideIndex) => {
        if (!milestone) return [];
        
        return [
          { x: milestone.x - width/2, y: milestone.y - height }, // Above, centered
          { x: milestone.x - width/2, y: milestone.y + 20 }, // Below, centered
          { x: milestone.x + 30, y: milestone.y - height/2 }, // Right
          { x: milestone.x - width - 30, y: milestone.y - height/2 }, // Left
          { x: milestone.x + 30, y: milestone.y - height }, // Top-right
          { x: milestone.x - width - 30, y: milestone.y - height }, // Top-left
          { x: milestone.x + 30, y: milestone.y + 20 }, // Bottom-right
          { x: milestone.x - width - 30, y: milestone.y + 20 } // Bottom-left
        ];
      };
      
      const positions1 = getPreferredPositions(milestone1, index1);
      const positions2 = getPreferredPositions(milestone2, index2);
      
      // Find best non-overlapping positions
      for (const pos1 of positions1) {
        for (const pos2 of positions2) {
          // Check if positions are valid (within bounds)
          if (isValidPosition(pos1, width, height) && isValidPosition(pos2, width, height)) {
            // Check if they don't overlap with each other
            if (!positionsOverlap(pos1, pos2, width, height)) {
              return { slide1: pos1, slide2: pos2 };
            }
          }
        }
      }
      
      // Fallback: spread them apart horizontally while keeping milestone association
      const fallback1 = milestone1 ? 
        { x: milestone1.x - width - 50, y: milestone1.y - height } :
        { x: slide1.x - totalWidth, y: slide1.y };
      const fallback2 = milestone2 ? 
        { x: milestone2.x + 50, y: milestone2.y - height } :
        { x: slide2.x + totalWidth, y: slide2.y };
        
      return { slide1: fallback1, slide2: fallback2 };
    }
    
    function isValidPosition(pos, width, height) {
      return pos.x >= 0 && pos.x + width <= 1920 && 
             pos.y >= 0 && pos.y + height <= 1080;
    }
    
    function positionsOverlap(pos1, pos2, width, height) {
      return !(pos1.x + width < pos2.x || 
               pos2.x + width < pos1.x || 
               pos1.y + height < pos2.y || 
               pos2.y + height < pos1.y);
    }

    function highlightOverlappingSlides() {
      const slides = document.querySelectorAll('.slide');
      const canvas = document.getElementById('canvas');
      const canvasRect = canvas.getBoundingClientRect();
      const scaleX = canvasRect.width / positions.virtualCanvas.width;
      const scaleY = canvasRect.height / positions.virtualCanvas.height;
      
      const SLIDE_WIDTH = 240;
      const SLIDE_BASE_HEIGHT = 150;
      const IMAGE_HEIGHT = 120;
      const IMAGE_MARGIN = 10;
      
      console.log('üîç Checking for overlaps...', {
        slideCount: slides.length,
        positionsCount: positions.slidePositions.length
      });
      
      // First, clear all existing warnings and borders from ALL slides
      slides.forEach((slide, index) => {
        slide.style.border = '';
        slide.style.removeProperty('border');
        const existingWarnings = slide.querySelectorAll('.overlap-warning');
        existingWarnings.forEach(warning => warning.remove());
        console.log(`Cleared warnings from slide ${index}`);
      });
      
      // Track which slides have overlaps
      const overlappingSlides = new Set();
      
      // Check each slide against all other slides
      for (let i = 0; i < positions.slidePositions.length; i++) {
        const pos1 = positions.slidePositions[i];
        if (!pos1) continue;
        
        // Calculate actual height for slide 1
        const event1 = events[i];
        const hasImage1 = event1 && event1.image && event1.image.length > 0;
        const height1 = SLIDE_BASE_HEIGHT + (hasImage1 ? IMAGE_HEIGHT + IMAGE_MARGIN : 0);
        
        for (let j = i + 1; j < positions.slidePositions.length; j++) {
          const pos2 = positions.slidePositions[j];
          if (!pos2) continue;
          
          // Calculate actual height for slide 2
          const event2 = events[j];
          const hasImage2 = event2 && event2.image && event2.image.length > 0;
          const height2 = SLIDE_BASE_HEIGHT + (hasImage2 ? IMAGE_HEIGHT + IMAGE_MARGIN : 0);
          
          // Check if slides overlap using the actual dimensions
          const overlap = !(
            pos1.x + SLIDE_WIDTH <= pos2.x || 
            pos2.x + SLIDE_WIDTH <= pos1.x || 
            pos1.y + height1 <= pos2.y || 
            pos2.y + height2 <= pos1.y
          );
          
          if (overlap) {
            overlappingSlides.add(i);
            overlappingSlides.add(j);
            console.log(`üö® Overlap detected between slides ${i} and ${j}`, {
              slide1: { x: pos1.x, y: pos1.y, height: height1, hasImage: hasImage1 },
              slide2: { x: pos2.x, y: pos2.y, height: height2, hasImage: hasImage2 }
            });
          }
        }
      }
      
      console.log(`Found ${overlappingSlides.size} overlapping slides:`, Array.from(overlappingSlides));
      
      // Apply warnings only to slides that are actually overlapping
      overlappingSlides.forEach(slideIndex => {
        const slide = slides[slideIndex];
        if (slide) {
          // Add red border with !important to ensure it applies
          slide.style.setProperty('border', '3px solid #ff4444', 'important');
          
          // Add warning icon
          const warning = document.createElement('div');
          warning.className = 'overlap-warning';
          warning.innerHTML = '‚ö†Ô∏è';
          warning.style.cssText = `
            position: absolute;
            top: -10px;
            right: -10px;
            background: #ff4444;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            z-index: 1000;
            pointer-events: none;
          `;
          slide.appendChild(warning);
          console.log(`‚úÖ Applied warning to slide ${slideIndex}`);
        }
      });
      
      if (overlappingSlides.size === 0) {
        console.log('‚úÖ No overlaps detected - all warnings cleared');
      }
    }

    // Tab Management Functions
    function switchTab(tabName) {
      // Remove active class from all tabs and buttons
      document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
      
      // Add active class to selected tab and button
      document.getElementById(tabName + '-tab').classList.add('active');
      document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
      
      // Load events when switching to events tab
      if (tabName === 'events') {
        loadEvents();
      }
      
      // Initialize theme preview when switching to theme and path tab
      if (tabName === 'themeAndPath') {
        const initialTheme = themes[currentThemeKey];
        if (initialTheme) {
          updateThemePreview(initialTheme);
        }
      }
    }

    // Events Management Functions
    let timelineEvents = [];

    async function loadEvents() {
      try {
        // Try to fetch from timeline.js
        const response = await fetch('timeline.js');
        if (response.ok) {
          const jsContent = await response.text();
          // Extract events array from the JavaScript file
          const eventsMatch = jsContent.match(/events:\s*\[([\s\S]*?)\]/);
          if (eventsMatch) {
            // Parse the events array (this is a simple approach)
            const eventsString = '[' + eventsMatch[1] + ']';
            try {
              timelineEvents = eval('(' + eventsString + ')');
            } catch (e) {
              console.warn('Could not parse events from timeline.js, using defaults');
              useDefaultEvents();
            }
          } else {
            useDefaultEvents();
          }
        } else {
          useDefaultEvents();
        }
      } catch (error) {
        console.warn('Could not load timeline.js, using defaults:', error);
        useDefaultEvents();
      }
      
      renderEventsList();
    }

    function useDefaultEvents() {
      timelineEvents = [
        {
          title: "Feb 2024: Project Start",
          content: 'UN Habitat tasks the innovation team to build a platform to improve cities be smarter. <a href="https://qolimpact.com/about" target="_blank" rel="noopener noreferrer">Learn more about the mandate here</a>',
          image: "assets/event1.png"
        },
        {
          title: "Jul 2024: The Innovation team is formed.",
          content: "The team included developers, designers, data analysts, product integration, researchers, and 3 external partners. <a href=\"team.html\" target=\"_blank\" rel=\"noopener noreferrer\">Meet the team here</a>",
          image: "assets/event2.png"
        }
      ];
    }

    function renderEventsList() {
      const eventsList = document.getElementById('events-list');
      eventsList.innerHTML = '';
      
      timelineEvents.forEach((event, index) => {
        const eventDiv = document.createElement('div');
        eventDiv.className = 'event-item';
        eventDiv.innerHTML = `
          <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 8px;">
            <small style="color: #999;">Event ${index + 1}</small>
            <button onclick="removeEvent(${index})" style="background: #d32f2f; color: white; border: none; padding: 2px 6px; border-radius: 3px; font-size: 10px; cursor: pointer; margin: 0 0 0 90%;">Remove</button>
          </div>
          <input type="text" class="event-input" placeholder="Event title" value="${event.title || ''}" onchange="updateEvent(${index}, 'title', this.value)">
          <textarea class="event-textarea" placeholder="Event content (HTML allowed)" onchange="updateEvent(${index}, 'content', this.value)">${event.content || ''}</textarea>
          <input type="text" class="event-input" placeholder="Image path (optional)" value="${event.image || ''}" onchange="updateEvent(${index}, 'image', this.value)">
        `;
        eventsList.appendChild(eventDiv);
      });
    }

    function addNewEvent() {
      timelineEvents.push({
        title: "New Event",
        content: "Event description",
        image: ""
      });
      renderEventsList();
    }

    function removeEvent(index) {
      if (confirm('Are you sure you want to remove this event?')) {
        timelineEvents.splice(index, 1);
        renderEventsList();
      }
    }

    function updateEvent(index, field, value) {
      if (timelineEvents[index]) {
        timelineEvents[index][field] = value;
      }
    }

    function saveEvents() {
      // Generate the timeline.js file content
      const jsContent = `function getTimelineData() {
  return {
    events: [
${timelineEvents.map(event => `        {
            title: ${JSON.stringify(event.title)},
            content: ${JSON.stringify(event.content)},
            image: ${JSON.stringify(event.image)}
        }`).join(',\n')}
    ]
  };
}`;

      // Create and download the file
      const blob = new Blob([jsContent], { type: 'application/javascript' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'timeline.js';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showTempMessage('üíæ timeline.js downloaded! Replace your existing file.');
    }

    // Theme Management Functions
    let themes = {
      "cosmic": {
        "name": "Cosmic Dark",
        "description": "Neutral gray theme with subtle effects",
        "colors": {
          "background": "#111",
          "containerBackground": "transparent",
          "textPrimary": "#fff",
          "textSecondary": "rgba(255, 255, 255, 0.8)",
          "pathGradient": {
            "start": "#6B7280",
            "middle": "#1E90FF", 
            "end": "#FF69B4"
          },
          "milestones": [
            "#6B7280",
            "#1E90FF", 
            "#00CED1",
            "#9370DB",
            "#FF69B4"
          ],
          "activeMilestone": "#6B7280",
          "controls": {
            "background": "rgba(255, 255, 255, 0.1)",
            "border": "rgba(255, 255, 255, 0.2)",
            "hover": "rgba(255, 255, 255, 0.2)",
            "zoomOutBorder": "#6B7280",
            "zoomOutHover": "rgba(107, 114, 128, 0.15)"
          }
        },
        "effects": {
          "pathGlow": "drop-shadow(0 0 12px rgba(100, 100, 255, 0.5))",
          "milestoneGlow": "0 0 0 4px rgba(255, 255, 255, 0.3), 0 0 10px rgba(255, 255, 255, 0.5)",
          "activeMilestoneGlow": "0 0 0 6px rgba(107, 114, 128, 0.4), 0 0 20px rgba(107, 114, 128, 0.8)",
          "controlsBackdrop": "blur(10px)",
          "controlsShadow": "0 4px 30px rgba(0, 0, 0, 0.1)"
        },
        "dimensions": {
          "pathWidth": 20,
          "milestoneSize": 24,
          "activeMilestoneSize": 32,
          "controlSize": 60,
          "slideOpacity": 0.1,
          "slideActiveOpacity": 1
        }
      },
      "minimal": {
        "name": "Minimal Light",
        "description": "Clean, minimal theme with subtle colors",
        "colors": {
          "background": "#f5f5f5",
          "containerBackground": "transparent",
          "textPrimary": "#333",
          "textSecondary": "rgba(51, 51, 51, 0.7)",
          "pathGradient": {
            "start": "#666",
            "middle": "#888",
            "end": "#666"
          },
          "milestones": [
            "#4A90E2",
            "#7ED321",
            "#F5A623",
            "#D0021B",
            "#9013FE"
          ],
          "activeMilestone": "#4A90E2",
          "controls": {
            "background": "rgba(255, 255, 255, 0.9)",
            "border": "rgba(0, 0, 0, 0.1)",
            "hover": "rgba(0, 0, 0, 0.05)",
            "zoomOutBorder": "#4A90E2",
            "zoomOutHover": "rgba(74, 144, 226, 0.1)"
          }
        },
        "effects": {
          "pathGlow": "none",
          "milestoneGlow": "0 2px 8px rgba(0, 0, 0, 0.1)",
          "activeMilestoneGlow": "0 4px 16px rgba(74, 144, 226, 0.3)",
          "controlsBackdrop": "blur(5px)",
          "controlsShadow": "0 2px 20px rgba(0, 0, 0, 0.1)"
        },
        "dimensions": {
          "pathWidth": 16,
          "milestoneSize": 20,
          "activeMilestoneSize": 28,
          "controlSize": 50,
          "slideOpacity": 0.2,
          "slideActiveOpacity": 1
        }
      }
    };

    let currentThemeKey = 'cosmic';

    function switchTheme() {
      const selector = document.getElementById('theme-selector');
      const selectedTheme = selector.value;
      const theme = themes[selectedTheme];
      
      if (theme) {
        currentThemeKey = selectedTheme;
        updateThemePreview(theme);
      }
    }

    function updateThemePreview(theme) {
      const themeInfo = document.getElementById('theme-info');
      themeInfo.innerHTML = `
        <strong>${theme.name}</strong><br>
        <small style="color: #bbb;">${theme.description}</small>
      `;
      
      // Update visual preview colors
      const previewContainer = document.getElementById('theme-visual-preview');
      const pathElement = document.getElementById('preview-path');
      const circles = [
        document.getElementById('preview-circle-1'),
        document.getElementById('preview-circle-2'),
        document.getElementById('preview-circle-3')
      ];
      const connectors = [
        document.getElementById('connector-1'),
        document.getElementById('connector-2'),
        document.getElementById('connector-3')
      ];
      const slideElements = [
        document.getElementById('preview-slide-1'),
        document.getElementById('preview-slide-2'),
        document.getElementById('preview-slide-3')
      ];
      const previewBackground = previewContainer.querySelector('div[style*="padding: 10px"]');
      
      // Update path
      if (pathElement) {
        pathElement.setAttribute('stroke', theme.colors.activeMilestone);
        pathElement.setAttribute('stroke-width', theme.dimensions.pathWidth || '3');
      }
      
      // Update milestone circles
      circles.forEach(circle => {
        if (circle) {
          circle.setAttribute('fill', theme.colors.activeMilestone);
          circle.setAttribute('stroke', theme.colors.textPrimary);
          circle.setAttribute('r', (theme.dimensions.milestoneSize || 8) / 2);
        }
      });
      
      // Update connector lines
      connectors.forEach(connector => {
        if (connector) {
          connector.setAttribute('stroke', 'rgba(255,255,255,0.4)');
        }
      });
      
      // Update slide elements
      slideElements.forEach(slide => {
        if (slide) {
          slide.setAttribute('fill', theme.colors.containerBackground || 'rgba(255, 255, 255, 0.1)');
          slide.setAttribute('stroke', theme.colors.activeMilestone);
        }
      });
      
      // Update background
      if (previewBackground) {
        previewBackground.style.background = theme.colors.background || '#111';
      }
    }

    async function applySelectedTheme() {
      const themeData = {
        currentTheme: currentThemeKey,
        themes: themes
      };

      // Create and download the theme.json file
      const themeJson = JSON.stringify(themeData, null, 2);
      const blob = new Blob([themeJson], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = 'theme.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showTempMessage(`üé® Applied ${themes[currentThemeKey].name} theme! Download and replace theme.json file.`);
    }

    async function downloadTheme() {
      const themeData = {
        currentTheme: currentThemeKey,
        themes: themes
      };

      const themeJson = JSON.stringify(themeData, null, 2);
      const blob = new Blob([themeJson], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = 'theme.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showTempMessage('üíæ theme.json downloaded!');
    }

    // Initialize theme selector
    document.addEventListener('DOMContentLoaded', () => {
      // Set initial theme preview
      const initialTheme = themes[currentThemeKey];
      if (initialTheme) {
        updateThemePreview(initialTheme);
      }
    });
    
    function createSaveScript() {
      // Create a simple PHP script that can save the positions
      const phpScript = `<?php
header('Content-Type: application/json');
header('Access-Control-Allow-Origin: *');
header('Access-Control-Allow-Methods: POST');
header('Access-Control-Allow-Headers: Content-Type');

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $input = file_get_contents('php://input');
    $data = json_decode($input, true);
    
    if ($data) {
        $result = file_put_contents('positions.json', json_encode($data, JSON_PRETTY_PRINT));
        if ($result !== false) {
            echo json_encode(['success' => true]);
        } else {
            http_response_code(500);
            echo json_encode(['error' => 'Failed to write file']);
        }
    } else {
        http_response_code(400);
        echo json_encode(['error' => 'Invalid JSON']);
    }
} else {
    http_response_code(405);
    echo json_encode(['error' => 'Method not allowed']);
}
?>`;

      // Download the PHP script
      const blob1 = new Blob([phpScript], { type: 'text/plain' });
      const url1 = URL.createObjectURL(blob1);
      const a1 = document.createElement('a');
      a1.href = url1;
      a1.download = 'save-positions.php';
      document.body.appendChild(a1);
      a1.click();
      document.body.removeChild(a1);
      URL.revokeObjectURL(url1);
      
      // Also download the updated positions.json as backup
      const dataStr = JSON.stringify(positions, null, 2);
      const blob2 = new Blob([dataStr], { type: 'application/json' });
      const url2 = URL.createObjectURL(blob2);
      const a2 = document.createElement('a');
      a2.href = url2;
      a2.download = 'positions.json';
      document.body.appendChild(a2);
      a2.click();
      document.body.removeChild(a2);
      URL.revokeObjectURL(url2);
      
      alert('üìÅ Downloaded save-positions.php script and updated positions.json!\n\n' +
            '1. Place save-positions.php in your web server directory\n' +
            '2. Replace the old positions.json with the new one\n' +
            '3. Future saves will work automatically!');
    }

    function showTemplatesModal() {
      document.getElementById('templates-modal').style.display = 'block';
    }

    function closeTemplatesModal() {
      document.getElementById('templates-modal').style.display = 'none';
    }

    // Close modal when clicking outside of it
    window.addEventListener('click', (event) => {
      const modal = document.getElementById('templates-modal');
      if (event.target === modal) {
        closeTemplatesModal();
      }
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      renderElements();
    });


    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOM loaded, initializing settings page');
      // Initialize template display
      updateTemplateDisplay('Loading...');
      loadPositions();
    });
    
    // Also try immediate initialization in case DOM is already loaded
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      console.log('DOM already ready, initializing settings page');
      loadPositions();
    }

    // Layout calculation function (improved for better SVG generation)
    function calculateLayout(eventCount, containerWidth, containerHeight, slideWidth, slideHeight, isMobile) {
      const milestonePoints = [];
      const slidePositions = [];
      const connectorData = [];

      if (eventCount === 0) {
        return { pathDefinition: '', milestonePoints: [], slidePositions: [], connectorData: [] };
      }

      // Better curved path calculation with more spacing
      const margin = 100;
      const startX = margin + 100;
      const endX = containerWidth - margin - 100;
      const startY = containerHeight * 0.15;
      const endY = containerHeight * 0.85;
      
      // Generate milestone points first
      for (let i = 0; i < eventCount; i++) {
        const progress = eventCount === 1 ? 0.5 : i / (eventCount - 1);
        
        // Create a more elegant S-curve
        const x = startX + (endX - startX) * progress;
        const waveAmplitude = 80;
        const waveFrequency = 1.5;
        const y = startY + (endY - startY) * progress + Math.sin(progress * Math.PI * waveFrequency) * waveAmplitude;
        
        milestonePoints.push({ x: Math.round(x), y: Math.round(y) });
      }
      
      // Generate smooth path through all points
      let pathDefinition = '';
      if (milestonePoints.length > 0) {
        pathDefinition = `M ${milestonePoints[0].x} ${milestonePoints[0].y}`;
        
        for (let i = 1; i < milestonePoints.length; i++) {
          const prev = milestonePoints[i - 1];
          const curr = milestonePoints[i];
          
          // Use quadratic curves for smoother paths
          if (i === 1) {
            pathDefinition += ` Q ${(prev.x + curr.x) / 2} ${prev.y} ${curr.x} ${curr.y}`;
          } else {
            const controlPointX = (prev.x + curr.x) / 2;
            const controlPointY = (prev.y + curr.y) / 2;
            pathDefinition += ` Q ${controlPointX} ${controlPointY} ${curr.x} ${curr.y}`;
          }
        }
      }
      
      // Position slides with better spacing
      milestonePoints.forEach((point, i) => {
        const isLeftSide = i % 2 === 0;
        const slideX = isLeftSide ? 
          Math.max(20, point.x - slideWidth - 80) : 
          Math.min(containerWidth - slideWidth - 20, point.x + 80);
        const slideY = Math.max(20, point.y - slideHeight / 2);
        
        slidePositions.push({ x: Math.round(slideX), y: Math.round(slideY) });
        
        // Store connector info for reference
        const startPoint = { 
          x: isLeftSide ? slideX + slideWidth : slideX, 
          y: point.y 
        };
        connectorData.push({ startPoint, milestone: point });
      });

      return { pathDefinition, milestonePoints, slidePositions, connectorData };
    }

    // Helper function to convert image to base64 and get dimensions
    async function imageToBase64(imagePath) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous'; // Enable CORS
        
        img.onload = function() {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // Set canvas size to image size
          canvas.width = img.naturalWidth;
          canvas.height = img.naturalHeight;
          
          // Draw image to canvas
          ctx.drawImage(img, 0, 0);
          
          // Convert to base64
          try {
            const dataURL = canvas.toDataURL('image/png');
            resolve({
              dataURL: dataURL,
              width: img.naturalWidth,
              height: img.naturalHeight,
              aspectRatio: img.naturalWidth / img.naturalHeight
            });
          } catch (error) {
            console.warn(`Failed to convert image to base64: ${imagePath}`, error);
            resolve(null);
          }
        };
        
        img.onerror = function() {
          console.warn(`Failed to load image: ${imagePath}`);
          resolve(null);
        };
        
        // Try loading the image
        img.src = imagePath;
      });
    }

    // Download SVG for Figma function
    async function downloadSVG() {
      console.log('=== SVG Download Started ===');
      try {
        // Get current theme
        const theme = themes[currentThemeKey];
        console.log('Current theme:', theme);
        
        // Use the same events data as the timeline preview
        console.log('Using events from timeline preview:', events.length, 'events');
        console.log('Using positions from timeline preview:', positions);
        
        // If no events or no positions loaded, show error
        if (!events || events.length === 0) {
          alert('No timeline events found. Please ensure the timeline data is loaded.');
          return;
        }
        
        if (!positions || !positions.milestonePoints || !positions.slidePositions) {
          alert('No timeline layout found. Please ensure the timeline positions are loaded.');
          return;
        }
        
        console.log(`=== Generating SVG with ${events.length} events ===`);
        console.log('Events data:', events);
        console.log('Layout data:', positions);
        
        // Use the exact same dimensions and layout as the timeline preview
        const canvasWidth = positions.virtualCanvas.width;
        const canvasHeight = positions.virtualCanvas.height;
        const slideWidth = 240;
        const slideHeight = 150;
        
        // Round coordinates for cleaner rendering
        const cleanPathDefinition = positions.pathDefinition.replace(/(\d+\.\d+)/g, (match) => {
          return Math.round(parseFloat(match)).toString();
        });
        
        console.log('Using exact positions from timeline preview:', {
          canvasWidth,
          canvasHeight,
          milestonePoints: positions.milestonePoints,
          slidePositions: positions.slidePositions,
          pathDefinition: positions.pathDefinition,
          cleanPathDefinition: cleanPathDefinition
        });
        
        // Load all images as base64
        const imagesToLoad = events.filter(event => event.image && event.image.trim() !== '').length;
        if (imagesToLoad > 0) {
          console.log(`Loading ${imagesToLoad} images...`);
          
          // Show loading feedback
          const originalButtonText = document.querySelector('button[onclick="downloadSVG()"]').textContent;
          const button = document.querySelector('button[onclick="downloadSVG()"]');
          button.textContent = '‚è≥ Loading images...';
          button.disabled = true;
        }
        
        const imagePromises = events.map(async (event, index) => {
          if (event.image && event.image.trim() !== '') {
            console.log(`Loading image ${index}: ${event.image}`);
            const imageData = await imageToBase64(event.image);
            return { 
              index, 
              imageData, 
              originalPath: event.image 
            };
          }
          return { 
            index, 
            imageData: null, 
            originalPath: null 
          };
        });
        
        const imageResults = await Promise.all(imagePromises);
        console.log('Image loading results:', imageResults);
        
        // Restore button
        if (imagesToLoad > 0) {
          const button = document.querySelector('button[onclick="downloadSVG()"]');
          button.textContent = 'üì• Download SVG for Figma';
          button.disabled = false;
        }
        
        // Create SVG structure with organized layers
        let svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
     width="${canvasWidth}" height="${canvasHeight}" viewBox="0 0 ${canvasWidth} ${canvasHeight}">
  
  <!-- Definitions for gradients and effects -->
  <defs>
    <linearGradient id="timeline-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" stop-color="#8A2BE2"/>
      <stop offset="25%" stop-color="#1E90FF"/>
      <stop offset="50%" stop-color="#00CED1"/>
      <stop offset="75%" stop-color="#9370DB"/>
      <stop offset="100%" stop-color="#FF69B4"/>
    </linearGradient>
    <filter id="glow" x="-100%" y="-100%" width="300%" height="300%" filterUnits="userSpaceOnUse" primitiveUnits="userSpaceOnUse">
      <feGaussianBlur stdDeviation="3" result="coloredBlur" in="SourceGraphic"/>
      <feMorphology operator="dilate" radius="1" result="dilated" in="coloredBlur"/>
      <feFlood flood-color="#ffffff" flood-opacity="0.3" result="flood"/>
      <feComposite in="flood" in2="dilated" operator="in" result="glow"/>
      <feMerge> 
        <feMergeNode in="glow"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
  </defs>
  
  <!-- Background Layer -->
  <g id="background-layer">
    <rect width="100%" height="100%" fill="${theme.colors.background || '#111'}"/>
  </g>
  
  <!-- Path Line Layer -->
  <g id="path-layer">
    <path d="${cleanPathDefinition}" 
          stroke="url(#timeline-gradient)" 
          stroke-width="${theme.dimensions?.pathWidth || 20}" 
          fill="none" 
          stroke-linecap="round" 
          stroke-linejoin="round"
          shape-rendering="geometricPrecision"
          filter="url(#glow)"/>
  </g>
  
  <!-- Connector Lines Layer -->
  <g id="connectors-layer">`;

        // Add connector lines first (behind other elements)
        positions.slidePositions.forEach((position, index) => {
          if (positions.milestonePoints[index]) {
            const milestone = positions.milestonePoints[index];
            // Determine connection point on slide (closest edge to milestone)
            let startX, startY;
            
            if (milestone.x < position.x + slideWidth / 2) {
              // Milestone is to the left, connect from left edge
              startX = position.x;
              startY = position.y + slideHeight / 2;
            } else {
              // Milestone is to the right, connect from right edge
              startX = position.x + slideWidth;
              startY = position.y + slideHeight / 2;
            }
            
            svgContent += `
    <line id="connector-${index}" 
          x1="${Math.round(startX)}" y1="${Math.round(startY)}" 
          x2="${Math.round(milestone.x)}" y2="${Math.round(milestone.y)}" 
          stroke="rgba(255,255,255,0.3)" 
          stroke-width="2" 
          stroke-dasharray="5,3"/>`;
          }
        });

        svgContent += `
  </g>
  
  <!-- Milestones Layer -->
  <g id="milestones-layer">`;

        // Add milestones - each as a separate editable element
        positions.milestonePoints.forEach((point, index) => {
          const colors = ['#8A2BE2', '#1E90FF', '#00CED1', '#9370DB', '#FF69B4'];
          const color = colors[index % colors.length];
          const radius = Math.round((theme.dimensions?.milestoneSize || 24) / 2);
          
          svgContent += `
    <circle id="milestone-${index}" 
            cx="${Math.round(point.x)}" cy="${Math.round(point.y)}" 
            r="${radius}" 
            fill="${color}" 
            stroke="#ffffff" 
            stroke-width="3" 
            shape-rendering="geometricPrecision"/>`;
        });

        svgContent += `
  </g>
  
  <!-- Events/Slides Layer -->
  <g id="events-layer">`;

        // Add event slides - each component as separate editable elements
        positions.slidePositions.forEach((position, index) => {
          const event = events[index];
          if (!event) return;
          
          svgContent += `
    <!-- Event ${index + 1}: ${escapeXml(event.title)} -->
    <g id="event-group-${index}">
      <!-- Event Background -->
      <rect id="event-bg-${index}" 
            x="${Math.round(position.x)}" y="${Math.round(position.y)}" 
            width="${slideWidth}" height="${slideHeight}" 
            fill="rgba(0,0,0,0.85)" 
            stroke="${theme.colors?.activeMilestone || '#6B7280'}" 
            stroke-width="2" 
            rx="8" ry="8" 
            shape-rendering="geometricPrecision"/>
      
      <!-- Event Title Group -->
      <g id="event-title-${index}">`;
          
          // Add event title as separate text elements
          const titleLines = wrapText(event.title, 28);
          titleLines.forEach((line, lineIndex) => {
            svgContent += `
        <text id="event-title-line-${index}-${lineIndex}" 
              x="${Math.round(position.x + 15)}" y="${Math.round(position.y + 30 + (lineIndex * 18))}" 
              fill="${theme.colors?.textPrimary || '#ffffff'}" 
              font-family="Arial, sans-serif" 
              font-size="15" 
              font-weight="bold" 
              text-rendering="geometricPrecision">${escapeXml(line)}</text>`;
          });
          
          svgContent += `
      </g>
      
      <!-- Event Content Group -->
      <g id="event-content-${index}">`;
          
          // Add event content as separate text elements
          const contentLines = wrapText(stripHtml(event.content), 32);
          const contentStartY = Math.round(position.y + 30 + (titleLines.length * 18) + 15);
          contentLines.slice(0, 7).forEach((line, lineIndex) => { // Allow more lines
            svgContent += `
        <text id="event-content-line-${index}-${lineIndex}" 
              x="${Math.round(position.x + 15)}" y="${contentStartY + (lineIndex * 14)}" 
              fill="rgba(255,255,255,0.9)" 
              font-family="Arial, sans-serif" 
              font-size="12" 
              text-rendering="geometricPrecision">${escapeXml(line)}</text>`;
          });
          
          svgContent += `
      </g>
      
      <!-- Event Image Placeholder -->
      <g id="event-image-${index}">`;
          
          // Add actual image if image exists
          const imageResult = imageResults.find(img => img.index === index);
          if (imageResult && (imageResult.imageData || imageResult.originalPath)) {
            const imageY = Math.round(contentStartY + (Math.min(contentLines.length, 7) * 14) + 10);
            const maxImageWidth = slideWidth - 30; // Available width
            const maxImageHeight = 100; // Maximum height we want to allow
            
            if (imageResult.imageData) {
              // Calculate proper dimensions maintaining aspect ratio
              const { dataURL, aspectRatio } = imageResult.imageData;
              
              let finalWidth, finalHeight;
              
              // Calculate dimensions that fit within our constraints while maintaining aspect ratio
              if (aspectRatio > 1) {
                // Landscape image - width is the limiting factor
                finalWidth = Math.min(maxImageWidth, imageResult.imageData.width);
                finalHeight = finalWidth / aspectRatio;
                
                // If height is too tall, recalculate based on height
                if (finalHeight > maxImageHeight) {
                  finalHeight = maxImageHeight;
                  finalWidth = finalHeight * aspectRatio;
                }
              } else {
                // Portrait or square image - height is usually the limiting factor
                finalHeight = Math.min(maxImageHeight, imageResult.imageData.height);
                finalWidth = finalHeight * aspectRatio;
                
                // If width is too wide, recalculate based on width
                if (finalWidth > maxImageWidth) {
                  finalWidth = maxImageWidth;
                  finalHeight = finalWidth / aspectRatio;
                }
              }
              
              // Center the image horizontally within the available space
              const imageX = Math.round(position.x + 15 + (maxImageWidth - finalWidth) / 2);
              
              console.log(`Image ${index}: original(${imageResult.imageData.width}x${imageResult.imageData.height}) ratio(${aspectRatio.toFixed(2)}) final(${finalWidth.toFixed(1)}x${finalHeight.toFixed(1)})`);
              
              svgContent += `
        <!-- Actual loaded image with proper aspect ratio -->
        <image id="event-image-${index}" 
               x="${imageX}" y="${imageY}" 
               width="${Math.round(finalWidth)}" height="${Math.round(finalHeight)}" 
               href="${dataURL}" 
               preserveAspectRatio="xMidYMid meet"/>`;
            } else if (imageResult.originalPath) {
              // Fallback: show placeholder with filename
              svgContent += `
        <!-- Image placeholder (failed to load) -->
        <rect id="event-image-bg-${index}" 
              x="${Math.round(position.x + 15)}" y="${imageY}" 
              width="${maxImageWidth}" height="${maxImageHeight}" 
              fill="rgba(107, 114, 128, 0.2)" 
              stroke="rgba(107, 114, 128, 0.5)" 
              stroke-width="1" 
              stroke-dasharray="3,2" 
              rx="4" 
              shape-rendering="geometricPrecision"/>
        <text id="event-image-label-${index}" 
              x="${Math.round(position.x + slideWidth/2)}" y="${imageY + maxImageHeight/2}" 
              text-anchor="middle" 
              fill="#6B7280" 
              font-family="Arial, sans-serif" 
              font-size="11" 
              text-rendering="geometricPrecision">üñºÔ∏è ${escapeXml(imageResult.originalPath)}</text>
        <text id="event-image-error-${index}" 
              x="${Math.round(position.x + slideWidth/2)}" y="${imageY + maxImageHeight/2 + 15}" 
              text-anchor="middle" 
              fill="#EF4444" 
              font-family="Arial, sans-serif" 
              font-size="9" 
              text-rendering="geometricPrecision">(Failed to load)</text>`;
            }
          }
          
          svgContent += `
      </g>
    </g>`;
        });

        svgContent += `
  </g>
  
  <!-- Images Layer (for future use) -->
  <g id="images-layer">
    <!-- Images would be added here as embedded base64 or external references -->
  </g>
  
</svg>`;

        console.log('SVG Content length:', svgContent.length);
        console.log('SVG Content preview:', svgContent.substring(0, 500));
        
        // Download the SVG file with timestamp to avoid caching
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const blob = new Blob([svgContent], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `timeline-for-figma-${timestamp}.svg`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        console.log(`=== SVG downloaded successfully as: timeline-for-figma-${timestamp}.svg ===`);
        alert(`SVG downloaded as: timeline-for-figma-${timestamp}.svg`);
        
      } catch (error) {
        console.error('Error generating SVG:', error);
        console.error('Error stack:', error.stack);
        alert('Error generating SVG. Please check the browser console for details.');
      }
    }

    // Helper functions for SVG generation
    function wrapText(text, maxChars) {
      const words = text.split(' ');
      const lines = [];
      let currentLine = '';
      
      words.forEach(word => {
        if ((currentLine + word).length <= maxChars) {
          currentLine += (currentLine ? ' ' : '') + word;
        } else {
          if (currentLine) lines.push(currentLine);
          currentLine = word;
        }
      });
      
      if (currentLine) lines.push(currentLine);
      return lines;
    }
    
    function stripHtml(html) {
      const temp = document.createElement('div');
      temp.innerHTML = html;
      return temp.textContent || temp.innerText || '';
    }
    
    function escapeXml(text) {
      return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }
  </script>
</body>
</html>