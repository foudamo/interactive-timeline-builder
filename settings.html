<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Timeline Position Settings</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Arial, sans-serif;
      background: #111;
      color: #fff;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
    }

    .header h1 {
      color: #8A2BE2;
      margin-bottom: 10px;
    }

    .canvas-container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      background: #222;
      border: 2px solid #444;
      border-radius: 8px;
      position: relative;
      aspect-ratio: 16/9;
    }

    .virtual-canvas {
      width: 100%;
      height: 100%;
      position: relative;
      background: linear-gradient(45deg, #1a1a1a 25%, transparent 25%), 
                  linear-gradient(-45deg, #1a1a1a 25%, transparent 25%), 
                  linear-gradient(45deg, transparent 75%, #1a1a1a 75%), 
                  linear-gradient(-45deg, transparent 75%, #1a1a1a 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
      overflow: hidden;
    }

    .milestone {
      width: 12px;
      height: 12px;
      background: #8A2BE2;
      border-radius: 50%;
      position: absolute;
      cursor: move;
      z-index: 10;
      transform: translate(-50%, -50%);
      border: 2px solid #fff;
      box-shadow: 0 0 8px rgba(138, 43, 226, 0.6);
    }

    .milestone:hover {
      transform: translate(-50%, -50%) scale(1.2);
    }

    .slide {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid #8A2BE2;
      border-radius: 4px;
      position: absolute;
      cursor: move;
      z-index: 8;
      font-size: 8px;
      color: #fff;
      text-align: left;
      padding: 8px;
      box-sizing: border-box;
      min-width: 100px;
      min-height: 60px;
      /* No overflow hidden - let content determine size */
    }
    
    .slide h3 {
      margin: 0 0 6px 0;
      font-size: 9px;
      font-weight: bold;
      color: #8A2BE2;
      line-height: 1.2;
    }
    
    .slide p {
      margin: 0 0 6px 0;
      font-size: 7px;
      line-height: 1.2;
      opacity: 0.9;
    }
    
    .slide .image-placeholder {
      width: 100%;
      height: 25px;
      background: rgba(138, 43, 226, 0.3);
      border-radius: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 6px;
      margin-top: 4px;
      flex-shrink: 0;
    }

    .slide:hover {
      background: rgba(138, 43, 226, 0.2);
    }

    .timeline-path {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }

    .path-line {
      stroke: #8A2BE2;
      stroke-width: 3;
      fill: none;
      stroke-linecap: round;
      filter: drop-shadow(0 0 4px rgba(138, 43, 226, 0.5));
    }

    .controls {
      max-width: 1200px;
      margin: 20px auto;
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .btn {
      background: #8A2BE2;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    .btn:hover {
      background: #9932CC;
      transform: translateY(-2px);
    }

    .btn.secondary {
      background: #444;
    }

    .btn.secondary:hover {
      background: #555;
    }

    .info {
      max-width: 1200px;
      margin: 20px auto;
      padding: 15px;
      background: rgba(138, 43, 226, 0.1);
      border: 1px solid #8A2BE2;
      border-radius: 6px;
      font-size: 14px;
      line-height: 1.5;
    }

    .dragging {
      opacity: 0.8;
      transform: scale(1.1);
      z-index: 20;
    }

    /* Modal Styles */
    .modal {
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(5px);
    }

    .modal-content {
      background: #222;
      margin: 2% auto;
      border-radius: 12px;
      width: 90%;
      max-width: 900px;
      max-height: 90vh;
      overflow-y: auto;
      border: 1px solid #444;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }

    .modal-header {
      padding: 20px 25px;
      border-bottom: 1px solid #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-body {
      padding: 25px;
    }

    .close {
      color: #aaa;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      transition: color 0.3s ease;
    }

    .close:hover {
      color: #8A2BE2;
    }

    .templates-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .template-item {
      background: #333;
      border-radius: 8px;
      padding: 15px;
      border-left: 4px solid #8A2BE2;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .template-preview {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 120px;
      background: #2a2a2a;
      border-radius: 6px;
      padding: 15px;
    }

    .shape-preview {
      width: 100%;
      height: 100%;
      max-width: 200px;
      max-height: 100px;
    }

    .template-item:hover {
      background: #3a3a3a;
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(138, 43, 226, 0.2);
    }

    .template-name {
      color: #8A2BE2;
      font-weight: bold;
      font-size: 16px;
      margin-bottom: 8px;
    }

    .template-desc {
      color: #bbb;
      font-size: 14px;
      line-height: 1.4;
    }

    /* Mini template previews */
    .mini-template {
      background: #2a2a2a;
      border-radius: 4px;
      padding: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 1px solid transparent;
    }

    .mini-template:hover {
      background: #3a3a3a;
      border-color: #8A2BE2;
      transform: scale(1.05);
    }

    .mini-shape {
      width: 100%;
      height: 100%;
    }

    /* Responsive design for settings row */
    @media (max-width: 768px) {
      .settings-row {
        grid-template-columns: 1fr !important;
        gap: 20px !important;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Timeline Position Settings</h1>
    <p>Drag and drop elements to customize their positions on the 16:9 virtual canvas</p>
  </div>

  <div id="template-info" style="text-align: center; margin: 10px 0; padding: 8px; background: rgba(138, 43, 226, 0.1); border-radius: 6px; border-left: 4px solid #8A2BE2;">
    <strong style="color: #8A2BE2;">Current Template:</strong> 
    <span id="template-name" style="color: #fff; font-weight: normal;">Loading...</span>
  </div>

  <div class="canvas-container">
    <div class="virtual-canvas" id="canvas">
      <svg class="timeline-path" id="timelinePath">
        <path class="path-line" id="pathLine" d=""></path>
      </svg>
    </div>
  </div>

  <div class="controls">
    <button class="btn" onclick="updateTimeline()">üîÑ Update Timeline</button>
    <button class="btn secondary" onclick="automaticallyGeneratePath()">‚ö° Automatically Generate Path</button>
    <button class="btn secondary" onclick="previewTimeline()">üëÅÔ∏è Preview Timeline</button>
  </div>
  
  <div class="settings-row" style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-top: 30px;">
    <!-- Left Side: Theme Settings -->
    <div class="theme-section" style="padding: 20px; background: #222; border-radius: 8px;">
      <h3 style="color: #8A2BE2; margin-bottom: 15px;">üé® Theme Settings</h3>
      <div class="theme-controls" style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap; margin-bottom: 20px;">
        <label style="color: #fff;">Current Theme:</label>
        <select id="theme-selector" onchange="switchTheme()" style="padding: 8px; background: #333; color: #fff; border: 1px solid #555; border-radius: 4px;">
          <option value="cosmic">Cosmic Dark</option>
          <option value="minimal">Minimal Light</option>
        </select>
        <button class="btn secondary" onclick="applySelectedTheme()">‚ú® Apply Theme</button>
        <button class="btn secondary" onclick="downloadTheme()">üíæ Download Theme</button>
      </div>
      <div id="theme-preview" style="padding: 15px; background: #111; border-radius: 6px; border-left: 4px solid #8A2BE2;">
        <div id="theme-info">
          <strong>Cosmic Dark</strong><br>
          <small style="color: #bbb;">Purple and blue cosmic theme with glowing effects</small>
        </div>
      </div>
    </div>
    
    <!-- Right Side: Templates Info -->
    <div class="templates-section" style="padding: 20px; background: #222; border-radius: 8px;">
      <h3 style="color: #8A2BE2; margin-bottom: 15px;">üìê Available Templates</h3>
      <p style="color: #bbb; margin-bottom: 15px;">Quick preview of timeline patterns:</p>
      
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 10px; max-height: 200px; overflow-y: auto;">
        <div class="mini-template" onclick="showTemplatesModal()" title="Alternating Left Right">
          <svg viewBox="0 0 40 30" class="mini-shape">
            <path d="M 8 8 L 8 22" stroke="#8A2BE2" stroke-width="1" fill="none"/>
            <circle cx="8" cy="8" r="1" fill="#8A2BE2"/>
            <circle cx="8" cy="15" r="1" fill="#8A2BE2"/>
            <circle cx="8" cy="22" r="1" fill="#8A2BE2"/>
            <rect x="12" y="6" width="8" height="4" fill="none" stroke="#666" stroke-width="0.5"/>
          </svg>
        </div>
        
        <div class="mini-template" onclick="showTemplatesModal()" title="Diamond Rhombus">
          <svg viewBox="0 0 40 30" class="mini-shape">
            <path d="M 20 8 L 28 15 L 20 22 L 12 15 Z" stroke="#8A2BE2" stroke-width="1" fill="none"/>
            <circle cx="20" cy="8" r="1" fill="#8A2BE2"/>
            <circle cx="28" cy="15" r="1" fill="#8A2BE2"/>
          </svg>
        </div>
        
        <div class="mini-template" onclick="showTemplatesModal()" title="Heart Teardrop">
          <svg viewBox="0 0 40 30" class="mini-shape">
            <path d="M 20 10 Q 15 6 12 10 Q 10 13 12 16 Q 15 19 20 16 Q 25 13 20 10" stroke="#8A2BE2" stroke-width="1" fill="none"/>
            <circle cx="20" cy="10" r="1" fill="#8A2BE2"/>
            <circle cx="12" cy="13" r="1" fill="#8A2BE2"/>
          </svg>
        </div>
        
        <div class="mini-template" onclick="showTemplatesModal()" title="Star Asterisk">
          <svg viewBox="0 0 40 30" class="mini-shape">
            <path d="M 20 6 L 22 10 L 26 8 L 24 13 L 28 15 L 23 16 L 24 21 L 20 18 L 16 21 L 17 16 L 12 15 L 16 13 L 14 8 L 18 10 Z" stroke="#8A2BE2" stroke-width="1" fill="none"/>
            <circle cx="20" cy="6" r="0.8" fill="#8A2BE2"/>
            <circle cx="26" cy="8" r="0.8" fill="#8A2BE2"/>
          </svg>
        </div>
        
        <div class="mini-template" onclick="showTemplatesModal()" title="Infinity Loop">
          <svg viewBox="0 0 40 30" class="mini-shape">
            <path d="M 12 15 Q 16 10 20 15 Q 24 20 28 15 Q 24 10 20 15 Q 16 20 12 15" stroke="#8A2BE2" stroke-width="1" fill="none"/>
            <circle cx="12" cy="15" r="1" fill="#8A2BE2"/>
            <circle cx="20" cy="15" r="1" fill="#8A2BE2"/>
          </svg>
        </div>
        
        <div class="mini-template" onclick="showTemplatesModal()" title="Spiral">
          <svg viewBox="0 0 40 30" class="mini-shape">
            <path d="M 20 15 Q 18 13 16 16 Q 14 18 17 17 Q 22 14 24 17" stroke="#8A2BE2" stroke-width="1" fill="none"/>
            <circle cx="20" cy="15" r="1" fill="#8A2BE2"/>
            <circle cx="16" cy="16" r="1" fill="#8A2BE2"/>
          </svg>
        </div>
      </div>
      
      <button class="btn secondary" onclick="showTemplatesModal()" style="width: 100%; margin-top: 15px;">
        ‚ÑπÔ∏è View All Templates
      </button>
    </div>
  </div>

  <!-- Templates Info Modal -->
  <div id="templates-modal" class="modal" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h2 style="color: #8A2BE2; margin: 0;">üìê Available Timeline Templates</h2>
        <span class="close" onclick="closeTemplatesModal()">&times;</span>
      </div>
      <div class="modal-body">
        <p style="color: #bbb; margin-bottom: 20px;">Choose from these professionally designed timeline patterns:</p>
        
        <div class="templates-grid">
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 20 20 L 20 60" stroke="#8A2BE2" stroke-width="2" fill="none"/>
                <circle cx="20" cy="20" r="3" fill="#8A2BE2"/>
                <circle cx="20" cy="40" r="3" fill="#8A2BE2"/>
                <circle cx="20" cy="60" r="3" fill="#8A2BE2"/>
                <rect x="30" y="15" width="25" height="10" fill="none" stroke="#666" stroke-width="1"/>
                <rect x="30" y="35" width="25" height="10" fill="none" stroke="#666" stroke-width="1"/>
                <rect x="30" y="55" width="25" height="10" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">üîÑ Alternating Left Right</div>
            <div class="template-desc">Vertical timeline with slides positioned to the right of milestone dots</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 10 60 L 30 60 L 30 40 L 50 40 L 50 20 L 70 20" stroke="#8A2BE2" stroke-width="2" fill="none"/>
                <circle cx="10" cy="60" r="3" fill="#8A2BE2"/>
                <circle cx="30" cy="40" r="3" fill="#8A2BE2"/>
                <circle cx="50" cy="20" r="3" fill="#8A2BE2"/>
                <rect x="75" y="15" width="20" height="10" fill="none" stroke="#666" stroke-width="1"/>
                <rect x="75" y="35" width="20" height="10" fill="none" stroke="#666" stroke-width="1"/>
                <rect x="75" y="55" width="20" height="10" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">üìä Stepped Timeline</div>
            <div class="template-desc">Staircase pattern with horizontal steps and vertical transitions</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 10 40 Q 30 20 50 40 Q 70 60 90 40" stroke="#8A2BE2" stroke-width="2" fill="none"/>
                <circle cx="10" cy="40" r="3" fill="#8A2BE2"/>
                <circle cx="50" cy="40" r="3" fill="#8A2BE2"/>
                <circle cx="90" cy="40" r="3" fill="#8A2BE2"/>
                <rect x="95" y="35" width="20" height="10" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">üåä Curved Centerline</div>
            <div class="template-desc">Elegant S-curve flowing across the canvas with alternating slide placement</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 10 50 Q 30 20 60 40 Q 90 60 110 30" stroke="#8A2BE2" stroke-width="2" fill="none"/>
                <circle cx="30" cy="30" r="3" fill="#8A2BE2"/>
                <circle cx="60" cy="40" r="3" fill="#8A2BE2"/>
                <circle cx="90" cy="50" r="3" fill="#8A2BE2"/>
                <rect x="85" y="15" width="18" height="8" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">üè¢ Company Milestone Curve</div>
            <div class="template-desc">Professional curved design inspired by corporate timeline layouts</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 60 20 L 80 40 L 60 60 L 40 40 Z" stroke="#8A2BE2" stroke-width="2" fill="none"/>
                <circle cx="60" cy="20" r="3" fill="#8A2BE2"/>
                <circle cx="80" cy="40" r="3" fill="#8A2BE2"/>
                <circle cx="60" cy="60" r="3" fill="#8A2BE2"/>
                <circle cx="40" cy="40" r="3" fill="#8A2BE2"/>
                <rect x="85" y="35" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">üíé Diamond Rhombus</div>
            <div class="template-desc">Geometric diamond shape with slides positioned around the perimeter</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 60 25 Q 45 15 35 25 Q 25 35 35 45 Q 45 55 60 45 Q 75 35 60 25" stroke="#8A2BE2" stroke-width="2" fill="none"/>
                <circle cx="60" cy="25" r="3" fill="#8A2BE2"/>
                <circle cx="35" cy="35" r="3" fill="#8A2BE2"/>
                <circle cx="60" cy="45" r="3" fill="#8A2BE2"/>
                <rect x="80" y="30" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">üíù Heart Teardrop</div>
            <div class="template-desc">Heart-shaped timeline using mathematical cardioid equations</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 60 15 L 70 25 L 80 20 L 75 35 L 85 45 L 70 50 L 75 65 L 60 60 L 45 65 L 50 50 L 35 45 L 45 35 L 40 20 L 50 25 Z" stroke="#8A2BE2" stroke-width="2" fill="none"/>
                <circle cx="60" cy="15" r="2" fill="#8A2BE2"/>
                <circle cx="80" cy="20" r="2" fill="#8A2BE2"/>
                <circle cx="85" cy="45" r="2" fill="#8A2BE2"/>
                <circle cx="60" cy="60" r="2" fill="#8A2BE2"/>
                <rect x="90" y="35" width="12" height="6" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">‚≠ê Star Asterisk</div>
            <div class="template-desc">8-pointed star with sharp tips and smooth valleys</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 30 40 Q 20 25 35 30 Q 50 20 55 35 Q 70 25 75 40 Q 90 30 85 45 Q 80 60 65 55 Q 50 65 45 50 Q 30 60 25 45 Q 15 50 30 40" stroke="#8A2BE2" stroke-width="2" fill="none"/>
                <circle cx="35" cy="30" r="2" fill="#8A2BE2"/>
                <circle cx="75" cy="40" r="2" fill="#8A2BE2"/>
                <circle cx="65" cy="55" r="2" fill="#8A2BE2"/>
                <circle cx="25" cy="45" r="2" fill="#8A2BE2"/>
                <rect x="90" y="35" width="12" height="6" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">‚òÅÔ∏è Cloud Organic</div>
            <div class="template-desc">Natural cloud-like shape with organic bulges and curves</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 30 40 Q 40 25 60 40 Q 80 55 90 40 Q 80 25 60 40 Q 40 55 30 40" stroke="#8A2BE2" stroke-width="2" fill="none"/>
                <circle cx="30" cy="40" r="3" fill="#8A2BE2"/>
                <circle cx="60" cy="40" r="3" fill="#8A2BE2"/>
                <circle cx="90" cy="40" r="3" fill="#8A2BE2"/>
                <rect x="95" y="35" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">‚ôæÔ∏è Infinity Loop</div>
            <div class="template-desc">Perfect figure-8 infinity symbol using lemniscate mathematics</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 60 40 Q 50 35 45 45 Q 35 50 30 45 Q 25 40 35 35 Q 45 30 55 35 Q 65 30 75 35 Q 85 40 80 50" stroke="#8A2BE2" stroke-width="2" fill="none"/>
                <circle cx="60" cy="40" r="3" fill="#8A2BE2"/>
                <circle cx="45" cy="45" r="3" fill="#8A2BE2"/>
                <circle cx="30" cy="45" r="3" fill="#8A2BE2"/>
                <circle cx="75" cy="35" r="3" fill="#8A2BE2"/>
                <rect x="85" y="45" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">üåÄ Spiral</div>
            <div class="template-desc">Wide spiral pattern expanding from center to edge with multiple rotations</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 10 50 Q 30 30 50 50 Q 70 70 90 50" stroke="#8A2BE2" stroke-width="2" fill="none"/>
                <circle cx="10" cy="50" r="3" fill="#8A2BE2"/>
                <circle cx="30" cy="40" r="3" fill="#8A2BE2"/>
                <circle cx="50" cy="50" r="3" fill="#8A2BE2"/>
                <circle cx="70" cy="60" r="3" fill="#8A2BE2"/>
                <circle cx="90" cy="50" r="3" fill="#8A2BE2"/>
                <rect x="95" y="45" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">„Ä∞Ô∏è Wave</div>
            <div class="template-desc">Smooth wave pattern alternating between upper and lower positions</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 10 40 L 90 40" stroke="#8A2BE2" stroke-width="2" fill="none"/>
                <circle cx="10" cy="40" r="3" fill="#8A2BE2"/>
                <circle cx="35" cy="40" r="3" fill="#8A2BE2"/>
                <circle cx="60" cy="40" r="3" fill="#8A2BE2"/>
                <circle cx="85" cy="40" r="3" fill="#8A2BE2"/>
                <rect x="15" y="25" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
                <rect x="40" y="25" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
                <rect x="65" y="25" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
                <rect x="90" y="25" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">üìè Linear</div>
            <div class="template-desc">Classic straight horizontal timeline with evenly spaced milestones</div>
          </div>
          
          <div class="template-item">
            <div class="template-preview">
              <svg viewBox="0 0 120 80" class="shape-preview">
                <path d="M 60 10 L 60 70" stroke="#8A2BE2" stroke-width="2" fill="none"/>
                <circle cx="60" cy="15" r="3" fill="#8A2BE2"/>
                <circle cx="60" cy="35" r="3" fill="#8A2BE2"/>
                <circle cx="60" cy="55" r="3" fill="#8A2BE2"/>
                <circle cx="60" cy="70" r="3" fill="#8A2BE2"/>
                <rect x="30" y="10" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
                <rect x="75" y="30" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
                <rect x="30" y="50" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
                <rect x="75" y="65" width="15" height="8" fill="none" stroke="#666" stroke-width="1"/>
              </svg>
            </div>
            <div class="template-name">üìê Vertical</div>
            <div class="template-desc">Vertical timeline flowing from top to bottom</div>
          </div>
        </div>
        
        <div style="margin-top: 20px; padding: 15px; background: rgba(138, 43, 226, 0.1); border-radius: 6px; border-left: 4px solid #8A2BE2;">
          <strong style="color: #8A2BE2;">üí° How to Use:</strong>
          <p style="color: #bbb; margin: 5px 0 0 0;">Click "‚ö° Automatically Generate Path" to randomly select and generate one of these templates. Each pattern is mathematically designed for optimal visual appeal and professional presentation.</p>
        </div>
      </div>
    </div>
  </div>

  <div class="info">
    <strong>How to Use:</strong>
    <ul style="margin-left: 20px; margin-top: 10px;">
      <li>Purple circles are milestone points (timeline dots)</li>
      <li>Rectangles are slide positions</li>
      <li>Drag elements to reposition them</li>
      <li>The timeline path automatically updates as you move milestones</li>
      <li>Click "Update Timeline" to download a new positions.json file</li>
    </ul>
  </div>

  <div class="info" style="background: #2c3e50; border-color: #34495e;">
    <strong>üì° Server Setup Instructions:</strong>
    <p style="margin: 10px 0;">Run a local server to access this page via HTTP:</p>
    
    <div style="background: #1a252f; padding: 15px; border-radius: 5px; margin: 10px 0; font-family: monospace;">
      <strong style="color: #3498db;">Python (Recommended):</strong><br>
      <code style="color: #e74c3c;">cd /path/to/your/timeline/folder</code><br>
      <code style="color: #e74c3c;">python3 -m http.server 8000</code><br>
      <small style="color: #95a5a6;">Then open: http://localhost:8000/settings.html</small>
    </div>

    <div style="background: #27ae60; padding: 15px; border-radius: 5px; margin: 10px 0;">
      <strong style="color: white;">üì• How "Update Timeline" Works:</strong><br>
      <span style="color: #ecf0f1;">
        1. Click "Update Timeline" button<br>
        2. A new positions.json file downloads automatically<br>
        3. Replace the old positions.json with the downloaded file<br>
        4. Refresh the main timeline to see your changes
      </span>
    </div>
  </div>

  <script>
    let positions = {
      virtualCanvas: { width: 1920, height: 1080 },
      milestonePoints: [],
      slidePositions: [],
      pathDefinition: ""
    };

    let currentTemplateName = 'Custom Layout';

    // Function to update template name display
    function updateTemplateDisplay(templateName) {
      currentTemplateName = templateName;
      const templateNameElement = document.getElementById('template-name');
      if (templateNameElement) {
        templateNameElement.textContent = templateName;
      }
    }

    let isDragging = false;
    let dragElement = null;
    let dragOffset = { x: 0, y: 0 };

    // Timeline events data - matches timeline.js
    const events = [
      {
        title: "Feb 2024: Project Start",
        content: 'UN Habitat tasks the innovation team to build a platform to improve cities be smarter. Learn more about the mandate here',
        image: "assets/event1.png"
      },
      {
        title: "Jul 2024: The Innovation team is formed.",
        content: "The team included developers, designers, data analysts, product integration, researchers, and 3 external partners. Meet the team here",
        image: "assets/event2.png"
      },
      {
        title: "Aug 2024: The first demo is delivered live.",
        content: "The demo included an AI chatbot that allows you to ask it on research done with the UN and how to improve each city. It also included a fictional ideal city that can be toured virtually to see what is possible in your city",
        image: ""
      },
      {
        title: "Sep 2024: 8 cities come online on the platform.",
        content: "This allowed the city admins of these cities to access admin panels, dashboard, and AI chatbot dedicated to their cities, which allowed them to make better decisions to improve their cities",
        image: "assets/event4.png"
      },
      {
        title: "Nov 2024: 3 more cities come online.",
        content: "All platforms (including external partners) are now fully integrated within one Data Lake. The UN is also given admin rights to enable them interactions with each live city",
        image: "assets/event5.png"
      },
      {
        title: "Feb 2025: The Quality of Life Initiative platform is delivered",
        content: 'Innovation team delivers the first part of phase one. Onboarding 11 cities out of 100, and allowing cities and city admins data science that can help them improve their cities. You can try it out here',
        image: "assets/event6.png"
      },
      {
        title: "March 2025: Data Collection started.",
        content: "This is the second part of phase one started. The 29 roughly indicators were created by the UN Habitat team in Collaboration with some research. The team partnered with a new vendor Veraset to source mobile ping data from the raw data. We're currently working on mobile ping data & Machine Learning",
        image: "assets/event7.png"
      },
      {
        title: "Dec 2025: End of Phase one",
        content: "We went global and partnered with civic tech leaders around the world.",
        image: ""
      },
      {
        title: "Jan 2026: Start of Phase two",
        content: "We rebuilt everything with AI-driven infrastructure.",
        image: ""
      }
    ];

    async function loadPositions() {
      // Skip fetch if running from file:// protocol to avoid CORS errors
      if (window.location.protocol === 'file:') {
        console.log('Running from file://, using default positions for settings preview');
        useDefaultPositions();
        renderElements();
        return;
      }
      
      try {
        const response = await fetch('positions.json');
        if (response.ok) {
          positions = await response.json();
          console.log('Loaded custom positions:', positions);
          updateTemplateDisplay('Current Layout');
        } else {
          console.warn('positions.json not found, using defaults');
          useDefaultPositions();
        }
      } catch (error) {
        console.warn('Could not load positions.json, using defaults:', error);
        useDefaultPositions();
      }
      renderElements();
    }

    function useDefaultPositions() {
      // Use the current positions from positions.json as the fallback
      // This ensures the settings page shows the actual current positions even when running from file://
      updateTemplateDisplay('Default Layout');
      positions = {
        "virtualCanvas": {
          "width": 1920,
          "height": 1080
        },
        "milestonePoints": [
          {"x": 163.09364548494983, "y": 587.7343265052763},
          {"x": 384, "y": 702},
          {"x": 561.5468227424749, "y": 220.65797641216636},
          {"x": 768, "y": 702},
          {"x": 960, "y": 378},
          {"x": 1152, "y": 702},
          {"x": 1344, "y": 378},
          {"x": 1536, "y": 702},
          {"x": 1728, "y": 378}
        ],
        "slidePositions": [
          {"x": 169.91638795986623, "y": 409.88206083178153},
          {"x": 264, "y": 602},
          {"x": 313.11872909698997, "y": 187.41154562383613},
          {"x": 648, "y": 602},
          {"x": 840, "y": 278},
          {"x": 1032, "y": 602},
          {"x": 1224, "y": 278},
          {"x": 1416, "y": 602},
          {"x": 1608, "y": 278}
        ],
        "pathDefinition": "M 163.09364548494983 587.7343265052763 C 229.3655518394649 587.7343265052763 317.72809364548493 702 384 702 C 437.26404682274244 702 508.28277591973244 220.65797641216636 561.5468227424749 220.65797641216636 C 623.4827759197324 220.65797641216636 706.0640468227425 702 768 702 C 825.6 702 902.4 378 960 378 C 1017.6 378 1094.4 702 1152 702 C 1209.6 702 1286.4 378 1344 378 C 1401.6 378 1478.4 702 1536 702 C 1593.6 702 1670.4 378 1728 378"
      };
    }

    function renderElements() {
      console.log('Rendering elements with positions:', positions);
      const canvas = document.getElementById('canvas');
      
      // Wait for canvas to be properly sized
      setTimeout(() => {
        const canvasRect = canvas.getBoundingClientRect();
        console.log('Canvas dimensions:', canvasRect.width, 'x', canvasRect.height);
        
        if (canvasRect.width === 0 || canvasRect.height === 0) {
          console.warn('Canvas not properly sized, retrying in 100ms');
          setTimeout(renderElements, 100);
          return;
        }
        
        const scaleX = canvasRect.width / positions.virtualCanvas.width;
        const scaleY = canvasRect.height / positions.virtualCanvas.height;
        console.log('Scale factors:', scaleX, scaleY);

        // Clear existing elements
        canvas.querySelectorAll('.milestone, .slide').forEach(el => el.remove());

        // Create milestones
        positions.milestonePoints.forEach((point, index) => {
          const milestone = document.createElement('div');
          milestone.className = 'milestone';
          milestone.dataset.type = 'milestone';
          milestone.dataset.index = index;
          const x = point.x * scaleX;
          const y = point.y * scaleY;
          milestone.style.left = x + 'px';
          milestone.style.top = y + 'px';
          milestone.title = `Milestone ${index + 1}: ${events[index] || 'Event ' + (index + 1)}`;
          console.log(`Created milestone ${index} at (${x}, ${y})`);
          canvas.appendChild(milestone);
        });

        // Create slides with realistic content
        positions.slidePositions.forEach((point, index) => {
          const slide = document.createElement('div');
          slide.className = 'slide';
          slide.dataset.type = 'slide';
          slide.dataset.index = index;
          const x = point.x * scaleX;
          const y = point.y * scaleY;
          
          const event = events[index];
          if (event) {
            // Use fixed dimensions matching the actual timeline slides
            const SLIDE_WIDTH = 240; // Match slides.js slide width
            const SLIDE_BASE_HEIGHT = 150; // Base slide height
            const IMAGE_HEIGHT = 120; // Height of image container from slides.js
            const IMAGE_MARGIN = 10;  // Margin-top of image from slides.js
            
            // Check if event has image for content building
            const hasImage = event.image && event.image.length > 0;
            
            // Calculate actual height including image if present
            let actualHeight = SLIDE_BASE_HEIGHT;
            if (hasImage) {
              actualHeight += IMAGE_HEIGHT + IMAGE_MARGIN;
            }
            
            let width = SLIDE_WIDTH * scaleX;
            let height = actualHeight * scaleY;
            
            // Build content HTML
            let contentHTML = `<h3>${event.title}</h3>`;
            
            // Show reasonable amount of content
            const maxContentChars = 180;
            const truncatedContent = event.content.length > maxContentChars 
              ? event.content.substring(0, maxContentChars) + '...' 
              : event.content;
            contentHTML += `<p>${truncatedContent}</p>`;
            
            // Add image placeholder if image exists - make it look more like actual image space
            if (hasImage) {
              contentHTML += `<div class="image-placeholder" style="
                width: 100%; 
                height: ${IMAGE_HEIGHT * scaleY}px; 
                margin-top: ${IMAGE_MARGIN * scaleY}px; 
                background: rgba(138, 43, 226, 0.2); 
                border: 1px dashed rgba(138, 43, 226, 0.5); 
                border-radius: 4px; 
                display: flex; 
                align-items: center; 
                justify-content: center; 
                font-size: 12px; 
                color: #8A2BE2;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
              ">üì∑ ${event.image}</div>`;
            }
            
            slide.innerHTML = contentHTML;
            slide.style.width = width + 'px';
            slide.style.height = height + 'px';
            slide.style.left = x + 'px';
            slide.style.top = y + 'px';
            slide.title = `${event.title} - Click to reposition`;
            
            console.log(`Slide ${index}: size(${width.toFixed(1)}x${height.toFixed(1)}) at (${x.toFixed(1)}, ${y.toFixed(1)})`);
          } else {
            // Fallback for missing events - use same fixed dimensions
            const SLIDE_WIDTH = 240;
            const SLIDE_HEIGHT = 150;
            slide.style.width = (SLIDE_WIDTH * scaleX) + 'px';
            slide.style.height = (SLIDE_HEIGHT * scaleY) + 'px';
            slide.style.left = x + 'px';
            slide.style.top = y + 'px';
            slide.innerHTML = `<div>Event ${index + 1}</div>`;
            slide.title = `Event ${index + 1}`;
          }
          
          canvas.appendChild(slide);
          console.log(`Created slide ${index} at (${x.toFixed(1)}, ${y.toFixed(1)})`);
        });

        updatePath();
        setupDragListeners();
        highlightOverlappingSlides();
      }, 50);
    }

    function updatePath() {
      const pathLine = document.getElementById('pathLine');
      if (!pathLine || positions.milestonePoints.length === 0) {
        console.warn('Path line element not found or no milestone points');
        return;
      }

      const canvasRect = document.getElementById('canvas').getBoundingClientRect();
      if (canvasRect.width === 0 || canvasRect.height === 0) {
        console.warn('Canvas not properly sized for path update');
        return;
      }
      
      const scaleX = canvasRect.width / positions.virtualCanvas.width;
      const scaleY = canvasRect.height / positions.virtualCanvas.height;

      // Create path for display (scaled to canvas)
      let displayPath = `M ${positions.milestonePoints[0].x * scaleX} ${positions.milestonePoints[0].y * scaleY}`;
      
      // Create path for export (virtual coordinates)
      let virtualPath = `M ${positions.milestonePoints[0].x} ${positions.milestonePoints[0].y}`;
      
      for (let i = 0; i < positions.milestonePoints.length - 1; i++) {
        const p1 = positions.milestonePoints[i];
        const p2 = positions.milestonePoints[i + 1];
        
        // Display path (scaled)
        const cp1x_display = p1.x * scaleX + (p2.x - p1.x) * scaleX * 0.3;
        const cp1y_display = p1.y * scaleY;
        const cp2x_display = p2.x * scaleX - (p2.x - p1.x) * scaleX * 0.3;
        const cp2y_display = p2.y * scaleY;
        displayPath += ` C ${cp1x_display},${cp1y_display} ${cp2x_display},${cp2y_display} ${p2.x * scaleX},${p2.y * scaleY}`;
        
        // Virtual path (original coordinates)
        const cp1x_virtual = p1.x + (p2.x - p1.x) * 0.3;
        const cp1y_virtual = p1.y;
        const cp2x_virtual = p2.x - (p2.x - p1.x) * 0.3;
        const cp2y_virtual = p2.y;
        virtualPath += ` C ${cp1x_virtual} ${cp1y_virtual} ${cp2x_virtual} ${cp2y_virtual} ${p2.x} ${p2.y}`;
      }
      
      console.log('Setting path:', displayPath);
      pathLine.setAttribute('d', displayPath);
      positions.pathDefinition = virtualPath; // Store virtual coordinates for export
    }

    function setupDragListeners() {
      const elements = document.querySelectorAll('.milestone, .slide');
      
      elements.forEach(element => {
        element.addEventListener('mousedown', startDrag);
      });

      document.addEventListener('mousemove', drag);
      document.addEventListener('mouseup', endDrag);
    }

    function startDrag(e) {
      isDragging = true;
      dragElement = e.target;
      dragElement.classList.add('dragging');
      
      const rect = dragElement.getBoundingClientRect();
      const canvasRect = document.getElementById('canvas').getBoundingClientRect();
      
      dragOffset.x = e.clientX - rect.left - rect.width / 2;
      dragOffset.y = e.clientY - rect.top - rect.height / 2;
      
      e.preventDefault();
    }

    function drag(e) {
      if (!isDragging || !dragElement) return;
      
      const canvas = document.getElementById('canvas');
      const canvasRect = canvas.getBoundingClientRect();
      const scaleX = canvasRect.width / positions.virtualCanvas.width;
      const scaleY = canvasRect.height / positions.virtualCanvas.height;
      
      const x = e.clientX - canvasRect.left - dragOffset.x;
      const y = e.clientY - canvasRect.top - dragOffset.y;
      
      // Constrain to canvas bounds
      const constrainedX = Math.max(0, Math.min(x, canvasRect.width));
      const constrainedY = Math.max(0, Math.min(y, canvasRect.height));
      
      dragElement.style.left = constrainedX + 'px';
      dragElement.style.top = constrainedY + 'px';
      
      // Update positions array
      const type = dragElement.dataset.type;
      const index = parseInt(dragElement.dataset.index);
      const virtualX = constrainedX / scaleX;
      const virtualY = constrainedY / scaleY;
      
      if (type === 'milestone') {
        positions.milestonePoints[index] = { x: virtualX, y: virtualY };
        updatePath();
      } else if (type === 'slide') {
        positions.slidePositions[index] = { x: virtualX, y: virtualY };
        highlightOverlappingSlides(); // Check for overlaps when slide is moved
      }
    }

    function endDrag() {
      if (dragElement) {
        dragElement.classList.remove('dragging');
        dragElement = null;
        
        // Check for overlaps after drag ends
        highlightOverlappingSlides();
        
        // Update template name to show it's been customized
        if (currentTemplateName !== 'Custom Layout') {
          updateTemplateDisplay('Custom Layout (Modified)');
        }
        
        // Auto-save positions after dragging (silent save)
        autoSavePositions();
      }
      isDragging = false;
    }
    
    async function autoSavePositions() {
      // Try to save silently to server
      try {
        const response = await fetch('save-positions.php', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(positions)
        });
        
        if (response.ok) {
          console.log('‚úÖ Positions auto-saved');
          showTempMessage('Auto-saved!');
          return;
        }
      } catch (error) {
        console.log('Auto-save to server not available');
      }
      
      // Store positions in localStorage as backup
      localStorage.setItem('timeline-positions', JSON.stringify(positions));
      console.log('Positions stored in localStorage');
    }
    
    function showTempMessage(message) {
      const msg = document.createElement('div');
      msg.textContent = message;
      msg.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #28a745;
        color: white;
        padding: 8px 16px;
        border-radius: 4px;
        z-index: 1000;
        font-size: 14px;
        opacity: 0;
        transition: opacity 0.3s ease;
      `;
      document.body.appendChild(msg);
      
      // Fade in
      setTimeout(() => msg.style.opacity = '1', 10);
      
      // Fade out and remove
      setTimeout(() => {
        msg.style.opacity = '0';
        setTimeout(() => document.body.removeChild(msg), 300);
      }, 2000);
    }

    async function updateTimeline() {
      // Store in localStorage as backup
      localStorage.setItem('timeline-positions', JSON.stringify(positions));
      
      // Generate and download the positions.json file
      const dataStr = JSON.stringify(positions, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(dataBlob);
      
      // Create download link
      const downloadLink = document.createElement('a');
      downloadLink.href = url;
      downloadLink.download = 'positions.json';
      downloadLink.style.display = 'none';
      
      // Trigger download
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);
      
      // Clean up the URL object
      URL.revokeObjectURL(url);
      
      // Show success message with clear instructions
      const message = `‚úÖ New positions.json downloaded!\n\n` +
                     `üìÅ Replace the old positions.json file with the downloaded one\n` +
                     `üîÑ Refresh main timeline to see changes`;
      
      alert(message);
      showTempMessage('üì• positions.json downloaded');
    }
    
    function automaticallyGeneratePath() {
      const eventCount = 9; // Number of events
      const virtualWidth = 1920;
      const virtualHeight = 1080;
      
      // Select a random pattern from available generators
      const patterns = [
        // Professional Timeline Layouts
        generateAlternatingLeftRightPattern,
        generateSteppedTimelinePattern,
        generateCurvedCenterlinePattern,
        generateCompanyMilestoneCurvePattern,
        generateDiamondRhombusPattern,
        generateHeartTeardropPattern,
        generateStarAsteriskPattern,
        generateCloudOrganicPattern,
        generateInfinityLoopPattern,
        generateVerticalBranchPattern,
        generateHorizontalBranchPattern,
        generateDiagonalStepsPattern,
        generateSConnectorPattern,
        generateMilestoneRoadPattern,
        generateFlowingRiverPattern,
        // Keep some original patterns for variety
        generateWavePattern,
        generateSpiralPattern,
        generateLinearPattern,
        generateVerticalPattern
      ];
      
      const selectedPattern = patterns[Math.floor(Math.random() * patterns.length)];
      const result = selectedPattern(eventCount, virtualWidth, virtualHeight);
      
      // Get the pattern name and format it nicely
      const patternName = selectedPattern.name || 'Generated Pattern';
      const displayName = patternName
        .replace(/^generate/, '')
        .replace(/Pattern$/, '')
        .replace(/([A-Z])/g, ' $1')
        .trim()
        .replace(/^\w/, c => c.toUpperCase());
      
      console.log(`Generated pattern: ${patternName}`);
      
      // Update positions
      positions.milestonePoints = result.milestones;
      positions.slidePositions = result.slides;
      positions.pathDefinition = result.pathDefinition;
      
      // Update template name display
      updateTemplateDisplay(displayName);
      
      // Re-render the preview only (no download)
      renderElements();
      
      // Show success message
      showTempMessage('Path generated! Click "Update Timeline" to download.');
    }

    // Pattern Generators
    function generateWavePattern(eventCount, virtualWidth, virtualHeight) {
      const spacing = virtualWidth / (eventCount + 1);
      const upperY = virtualHeight * 0.35;
      const lowerY = virtualHeight * 0.65;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const x = spacing * (i + 1);
        const y = (i % 2 === 0) ? upperY : lowerY;
        
        newMilestones.push({ x, y });
        newSlides.push({ 
          x: x,
          y: y - 150  // Bottom-left corner aligned with dot (slide height is ~150px)
        });
      }
      
      // Enhanced wave curves with varying tangent styles
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        
        // Vary curve tension and tangent behavior
        const curveVariation = i % 4;
        let cp1X, cp1Y, cp2X, cp2Y;
        
        if (curveVariation === 0) {
          // Horizontal tangents - classic S-curve
          cp1X = current.x + (next.x - current.x) * 0.6;
          cp1Y = current.y;
          cp2X = current.x + (next.x - current.x) * 0.4;
          cp2Y = next.y;
        } else if (curveVariation === 1) {
          // Diagonal tangents - more dynamic
          cp1X = current.x + (next.x - current.x) * 0.3;
          cp1Y = current.y + (next.y - current.y) * 0.2;
          cp2X = current.x + (next.x - current.x) * 0.7;
          cp2Y = current.y + (next.y - current.y) * 0.8;
        } else if (curveVariation === 2) {
          // Curved tangents - flowing motion
          const midX = (current.x + next.x) / 2;
          const amplitude = Math.abs(next.y - current.y) * 0.4;
          cp1X = midX - amplitude;
          cp1Y = current.y + (next.y - current.y) * 0.1;
          cp2X = midX + amplitude;
          cp2Y = current.y + (next.y - current.y) * 0.9;
        } else {
          // Sharp tangents - angular transitions
          cp1X = current.x + (next.x - current.x) * 0.8;
          cp1Y = current.y + (next.y - current.y) * 0.1;
          cp2X = current.x + (next.x - current.x) * 0.2;
          cp2Y = current.y + (next.y - current.y) * 0.9;
        }
        
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateZigZagPattern(eventCount, virtualWidth, virtualHeight) {
      const spacing = virtualWidth / (eventCount + 1);
      const topY = virtualHeight * 0.2;
      const bottomY = virtualHeight * 0.8;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const x = spacing * (i + 1);
        const y = (i % 2 === 0) ? topY : bottomY;
        
        newMilestones.push({ x, y });
        newSlides.push({ 
          x: x,
          y: y - 150  // Bottom-left corner aligned with dot (slide height is ~150px)
        });
      }
      
      // Enhanced zigzag with curved transitions and varying sharpness
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        
        // Alternate between sharp angles and smooth curves
        const transitionType = i % 3;
        
        if (transitionType === 0) {
          // Sharp linear transition
          pathDefinition += ` L ${next.x} ${next.y}`;
        } else if (transitionType === 1) {
          // Smooth curved transition
          const cp1X = current.x + (next.x - current.x) * 0.7;
          const cp1Y = current.y;
          const cp2X = current.x + (next.x - current.x) * 0.3;
          const cp2Y = next.y;
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
        } else {
          // Rounded corner transition
          const cornerRadius = 30;
          const cp1X = current.x + (next.x - current.x) * 0.8;
          const cp1Y = current.y + (next.y - current.y) * 0.2;
          const cp2X = current.x + (next.x - current.x) * 0.2;
          const cp2Y = current.y + (next.y - current.y) * 0.8;
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
        }
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateLinearPattern(eventCount, virtualWidth, virtualHeight) {
      const spacing = virtualWidth * 0.8 / (eventCount - 1);
      const startX = virtualWidth * 0.1;
      const centerY = virtualHeight * 0.5;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const x = startX + i * spacing;
        const y = centerY;
        
        newMilestones.push({ x, y });
        newSlides.push({ 
          x: x - 120, // Center slide horizontally on milestone
          y: y - 150  // Position slide above the line
        });
      }
      
      // Create straight horizontal line path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 1; i < newMilestones.length; i++) {
        const curr = newMilestones[i];
        pathDefinition += ` L ${curr.x} ${curr.y}`;
      }
      
      console.log('Linear pattern pathDefinition:', pathDefinition);
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateVerticalPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth * 0.5;
      const spacing = virtualHeight / (eventCount + 1);
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const x = centerX + (Math.sin(i * 0.5) * 200); // Slight wave for visual interest
        const y = spacing * (i + 1);
        
        newMilestones.push({ x, y });
        newSlides.push({ 
          x: x,
          y: y - 150  // Bottom-left corner aligned with dot (slide height is ~150px)
        });
      }
      
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const midY = (current.y + next.y) / 2;
        const cp1X = current.x;
        const cp1Y = current.y + (midY - current.y) * 0.3;
        const cp2X = next.x;
        const cp2Y = next.y - (next.y - midY) * 0.3;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateHorizontalPattern(eventCount, virtualWidth, virtualHeight) {
      const spacing = virtualWidth / (eventCount + 1);
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const x = spacing * (i + 1);
        const y = virtualHeight * 0.5 + (Math.sin(i * 0.8) * 150); // Horizontal with vertical wave
        
        newMilestones.push({ x, y });
        newSlides.push({ 
          x: x,
          y: y - 150  // Bottom-left corner aligned with dot (slide height is ~150px)
        });
      }
      
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const midX = (current.x + next.x) / 2;
        const cp1X = current.x + (midX - current.x) * 0.4;
        const cp1Y = current.y;
        const cp2X = next.x - (next.x - midX) * 0.4;
        const cp2Y = next.y;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateSpiralPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth * 0.5;
      const centerY = virtualHeight * 0.5;
      const maxRadius = Math.min(virtualWidth, virtualHeight) * 0.48; // Maximum spread - nearly edge to edge
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        // Create more spacing between spiral arms by using fewer rotations but more gradual expansion
        const progress = i / (eventCount - 1);
        const angle = progress * 5 * Math.PI; // 2.5 rotations for wider arm spacing
        
        // Use progressive radius expansion that matches your sketch - starts slow, accelerates
        const radiusProgress = Math.pow(progress, 0.7); // Curved expansion like your drawing
        const radius = radiusProgress * maxRadius;
        
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;
        
        newMilestones.push({ x, y });
        
        // Position slides tangentially to the spiral curve with better spacing
        const slideRadius = radius + 120; // More space from spiral
        const slideAngle = angle + Math.PI/3; // Better angular offset
        const slideX = centerX + Math.cos(slideAngle) * slideRadius;
        const slideY = centerY + Math.sin(slideAngle) * slideRadius - 75;
        
        newSlides.push({ 
          x: slideX,
          y: slideY
        });
      }
      
      // Enhanced spiral with varying curve tensions and tangent directions
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        
        // Calculate tangent direction based on spiral rotation
        const currentAngle = (i / eventCount) * 4 * Math.PI;
        const nextAngle = ((i + 1) / eventCount) * 4 * Math.PI;
        
        // Vary control point placement for different spiral segments
        const spiralVariation = Math.floor(i / (eventCount / 4)) % 3;
        let cp1X, cp1Y, cp2X, cp2Y;
        
        if (spiralVariation === 0) {
          // Tight spiral curves - closer control points
          const tangentLength = 0.15;
          cp1X = current.x + Math.cos(currentAngle + Math.PI/2) * tangentLength * 50;
          cp1Y = current.y + Math.sin(currentAngle + Math.PI/2) * tangentLength * 50;
          cp2X = next.x - Math.cos(nextAngle + Math.PI/2) * tangentLength * 50;
          cp2Y = next.y - Math.sin(nextAngle + Math.PI/2) * tangentLength * 50;
        } else if (spiralVariation === 1) {
          // Loose spiral curves - wider control points
          const tangentLength = 0.4;
          cp1X = current.x + Math.cos(currentAngle) * tangentLength * 80;
          cp1Y = current.y + Math.sin(currentAngle) * tangentLength * 80;
          cp2X = next.x - Math.cos(nextAngle) * tangentLength * 80;
          cp2Y = next.y - Math.sin(nextAngle) * tangentLength * 80;
        } else {
          // Mixed tangent approach - asymmetric control
          cp1X = current.x + (next.x - current.x) * 0.3;
          cp1Y = current.y + (next.y - current.y) * 0.1;
          cp2X = current.x + (next.x - current.x) * 0.9;
          cp2Y = current.y + (next.y - current.y) * 0.7;
        }
        
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateDiagonalPattern(eventCount, virtualWidth, virtualHeight) {
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const x = virtualWidth * 0.1 + progress * virtualWidth * 0.8;
        const y = virtualHeight * 0.2 + progress * virtualHeight * 0.6;
        
        newMilestones.push({ x, y });
        newSlides.push({ 
          x: x,
          y: y - 150  // Bottom-left corner aligned with dot (slide height is ~150px)
        });
      }
      
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const cp1X = current.x + (next.x - current.x) * 0.3;
        const cp1Y = current.y + (next.y - current.y) * 0.3;
        const cp2X = current.x + (next.x - current.x) * 0.7;
        const cp2Y = current.y + (next.y - current.y) * 0.7;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    // New Creative Timeline Patterns

    function generateDNAHelixPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth / 2;
      const amplitude = Math.min(virtualWidth, virtualHeight) * 0.15;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const angle = progress * Math.PI * 4; // 4 full rotations
        
        // Create DNA helix with two intertwined spirals
        const helixRadius = amplitude * (0.5 + 0.5 * Math.sin(angle * 2));
        const x = centerX + helixRadius * Math.cos(angle);
        const y = virtualHeight * 0.1 + progress * virtualHeight * 0.8;
        
        newMilestones.push({ x, y });
        newSlides.push({ x, y: y - 150 });
      }
      
      // Create smooth curved path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const cp1X = current.x + (next.x - current.x) * 0.3;
        const cp1Y = current.y + (next.y - current.y) * 0.3;
        const cp2X = current.x + (next.x - current.x) * 0.7;
        const cp2Y = current.y + (next.y - current.y) * 0.7;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateInfinityPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth / 2;
      const centerY = virtualHeight / 2;
      const scaleX = virtualWidth * 0.3;
      const scaleY = virtualHeight * 0.25;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const t = (i / (eventCount - 1)) * 4 * Math.PI; // Full infinity loop
        
        // Parametric equations for infinity symbol (lemniscate)
        const cos_t = Math.cos(t);
        const sin_t = Math.sin(t);
        const denominator = 1 + sin_t * sin_t;
        
        const x = centerX + (scaleX * cos_t) / denominator;
        const y = centerY + (scaleY * sin_t * cos_t) / denominator;
        
        newMilestones.push({ x, y });
        newSlides.push({ x, y: y - 150 });
      }
      
      // Create smooth curved path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const cp1X = current.x + (next.x - current.x) * 0.4;
        const cp1Y = current.y + (next.y - current.y) * 0.4;
        const cp2X = current.x + (next.x - current.x) * 0.6;
        const cp2Y = current.y + (next.y - current.y) * 0.6;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateChevronPattern(eventCount, virtualWidth, virtualHeight) {
      const newMilestones = [];
      const newSlides = [];
      const chevronHeight = virtualHeight * 0.15;
      const startY = virtualHeight * 0.2;
      
      for (let i = 0; i < eventCount; i++) {
        const segmentProgress = i / (eventCount - 1);
        const chevronCount = Math.floor(segmentProgress * 4); // 4 chevron peaks
        const withinChevron = (segmentProgress * 4) % 1;
        
        let x, y;
        
        if (withinChevron <= 0.5) {
          // Going up the chevron
          x = virtualWidth * 0.1 + segmentProgress * virtualWidth * 0.8;
          y = startY + chevronCount * chevronHeight + withinChevron * 2 * chevronHeight;
        } else {
          // Going down the chevron
          x = virtualWidth * 0.1 + segmentProgress * virtualWidth * 0.8;
          y = startY + chevronCount * chevronHeight + (2 - withinChevron * 2) * chevronHeight;
        }
        
        newMilestones.push({ x, y });
        newSlides.push({ x, y: y - 150 });
      }
      
      // Create angular path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const next = newMilestones[i + 1];
        pathDefinition += ` L ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateFigureEightPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth / 2;
      const centerY = virtualHeight / 2;
      const radiusX = virtualWidth * 0.25;
      const radiusY = virtualHeight * 0.3;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const t = (i / (eventCount - 1)) * 2 * Math.PI;
        
        // Figure-8 parametric equations
        const x = centerX + radiusX * Math.sin(t);
        const y = centerY + radiusY * Math.sin(t) * Math.cos(t);
        
        newMilestones.push({ x, y });
        newSlides.push({ x, y: y - 150 });
      }
      
      // Create smooth curved path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const cp1X = current.x + (next.x - current.x) * 0.3;
        const cp1Y = current.y + (next.y - current.y) * 0.3;
        const cp2X = current.x + (next.x - current.x) * 0.7;
        const cp2Y = current.y + (next.y - current.y) * 0.7;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateSinusoidalPattern(eventCount, virtualWidth, virtualHeight) {
      const newMilestones = [];
      const newSlides = [];
      const amplitude = virtualHeight * 0.2;
      const frequency = 3; // Number of complete waves
      const centerY = virtualHeight / 2;
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const x = virtualWidth * 0.1 + progress * virtualWidth * 0.8;
        const y = centerY + amplitude * Math.sin(progress * frequency * 2 * Math.PI);
        
        newMilestones.push({ x, y });
        newSlides.push({ x, y: y - 150 });
      }
      
      // Create smooth sinusoidal path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const cp1X = current.x + (next.x - current.x) * 0.25;
        const cp1Y = current.y;
        const cp2X = current.x + (next.x - current.x) * 0.75;
        const cp2Y = next.y;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateGoldenSpiralPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth / 2;
      const centerY = virtualHeight / 2;
      const goldenRatio = 1.618033988749;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const angle = progress * 4 * Math.PI; // 4 rotations
        const radius = Math.min(virtualWidth, virtualHeight) * 0.3 * Math.pow(goldenRatio, progress * 2 - 1);
        
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);
        
        newMilestones.push({ x, y });
        newSlides.push({ x, y: y - 150 });
      }
      
      // Create smooth spiral path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const cp1X = current.x + (next.x - current.x) * 0.3;
        const cp1Y = current.y + (next.y - current.y) * 0.3;
        const cp2X = current.x + (next.x - current.x) * 0.7;
        const cp2Y = current.y + (next.y - current.y) * 0.7;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateAccordionPattern(eventCount, virtualWidth, virtualHeight) {
      const newMilestones = [];
      const newSlides = [];
      const foldWidth = virtualWidth * 0.15;
      const foldHeight = virtualHeight * 0.8 / Math.ceil(eventCount / 2);
      
      for (let i = 0; i < eventCount; i++) {
        const row = Math.floor(i / 2);
        const isEvenRow = row % 2 === 0;
        const isLeftSide = i % 2 === 0;
        
        let x, y;
        
        if (isEvenRow) {
          // Even rows: left to right
          x = virtualWidth * 0.1 + (isLeftSide ? 0 : foldWidth);
        } else {
          // Odd rows: right to left
          x = virtualWidth * 0.9 - (isLeftSide ? 0 : foldWidth);
        }
        
        y = virtualHeight * 0.1 + row * foldHeight + foldHeight * 0.5;
        
        newMilestones.push({ x, y });
        newSlides.push({ x, y: y - 150 });
      }
      
      // Create accordion-style path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 1; i < newMilestones.length; i++) {
        const prev = newMilestones[i - 1];
        const curr = newMilestones[i];
        
        // Create accordion folds
        if (i % 2 === 1) {
          // Going to the fold
          pathDefinition += ` L ${curr.x} ${curr.y}`;
        } else {
          // Coming back from the fold
          const midY = (prev.y + curr.y) / 2;
          pathDefinition += ` L ${prev.x} ${midY} L ${curr.x} ${midY} L ${curr.x} ${curr.y}`;
        }
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    // Professional Timeline Layout Patterns

    function generateAlternatingLeftRightPattern(eventCount, virtualWidth, virtualHeight) {
      console.log('GENERATING ALTERNATING LEFT RIGHT PATTERN - SLIDES TO RIGHT OF DOTS');
      const centerX = virtualWidth / 2;
      const verticalSpacing = virtualHeight * 0.8 / (eventCount - 1);
      const horizontalOffset = 300; // Distance from center line
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const y = virtualHeight * 0.1 + i * verticalSpacing;
        const x = centerX; // All milestones on center line
        
        newMilestones.push({ x, y });
        
        // Place all slides to the right of each dot with proper spacing
        const slideX = x + 300; // Position slide 300px to the right of the dot to ensure no overlap
        newSlides.push({ x: slideX, y: y - 75 });
      }
      
      // Create straight vertical path down the center
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 1; i < newMilestones.length; i++) {
        pathDefinition += ` L ${newMilestones[i].x} ${newMilestones[i].y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateSteppedTimelinePattern(eventCount, virtualWidth, virtualHeight) {
      const stepWidth = virtualWidth * 0.7 / eventCount;
      const stepHeight = 100;
      const startX = virtualWidth * 0.15;
      const startY = virtualHeight * 0.7;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const x = startX + i * stepWidth;
        const y = startY - (i % 2) * stepHeight; // Alternate high/low steps
        
        newMilestones.push({ x, y });
        
        // Position slides above the steps
        const slideY = y - 200;
        newSlides.push({ x: x - 120, y: slideY });
      }
      
      // Create stepped path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 1; i < newMilestones.length; i++) {
        const prev = newMilestones[i - 1];
        const curr = newMilestones[i];
        // Create step-like path with right angles
        const midX = (prev.x + curr.x) / 2;
        pathDefinition += ` L ${midX} ${prev.y} L ${midX} ${curr.y} L ${curr.x} ${curr.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateCurvedCenterlinePattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth / 2;
      const newMilestones = [];
      const newSlides = [];
      const curveAmplitude = virtualWidth * 0.4; // Maximum amplitude - 40% of canvas width
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const y = virtualHeight * 0.02 + progress * virtualHeight * 0.96; // Use 96% of vertical space
        
        // Create wide S-curve that spans most of the canvas width
        const curveOffset = Math.sin(progress * Math.PI * 1.5) * curveAmplitude;
        const x = centerX + curveOffset;
        
        newMilestones.push({ x, y });
        
        // Position slides alternately on opposite sides of curve
        const isLeft = (curveOffset > 0) !== (i % 2 === 0); // Smart alternation based on curve
        const slideX = isLeft ? x - 350 : x + 110;
        newSlides.push({ x: slideX, y: y - 75 });
      }
      
      // Create smooth curved path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 1; i < newMilestones.length; i++) {
        const prev = newMilestones[i - 1];
        const curr = newMilestones[i];
        const cp1X = prev.x;
        const cp1Y = prev.y + (curr.y - prev.y) * 0.5;
        const cp2X = curr.x;
        const cp2Y = curr.y - (curr.y - prev.y) * 0.5;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${curr.x} ${curr.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateVerticalBranchPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth * 0.2; // Main trunk on left side
      const branchLength = 200;
      const verticalSpacing = virtualHeight * 0.8 / (eventCount - 1);
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const y = virtualHeight * 0.1 + i * verticalSpacing;
        
        // Trunk milestone
        const trunkX = centerX;
        
        // Branch extends right from trunk
        const branchX = trunkX + branchLength;
        newMilestones.push({ x: branchX, y });
        
        // Position slide at end of branch
        newSlides.push({ x: branchX + 20, y: y - 75 });
      }
      
      // Create branching path - vertical trunk with horizontal branches
      let pathDefinition = `M ${centerX} ${virtualHeight * 0.1}`;
      pathDefinition += ` L ${centerX} ${virtualHeight * 0.9}`; // Main trunk
      
      // Add branches
      for (let i = 0; i < newMilestones.length; i++) {
        const milestone = newMilestones[i];
        pathDefinition += ` M ${centerX} ${milestone.y} L ${milestone.x} ${milestone.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateHorizontalBranchPattern(eventCount, virtualWidth, virtualHeight) {
      const centerY = virtualHeight / 2; // Main trunk horizontally centered
      const branchLength = 150;
      const horizontalSpacing = virtualWidth * 0.7 / (eventCount - 1);
      const startX = virtualWidth * 0.15;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const x = startX + i * horizontalSpacing;
        
        // Alternate branches above and below trunk
        const isAbove = i % 2 === 0;
        const branchY = isAbove ? centerY - branchLength : centerY + branchLength;
        newMilestones.push({ x, y: branchY });
        
        // Position slide near branch end
        const slideY = isAbove ? branchY - 150 : branchY + 20;
        newSlides.push({ x: x - 120, y: slideY });
      }
      
      // Create branching path - horizontal trunk with vertical branches
      let pathDefinition = `M ${startX} ${centerY} L ${startX + (eventCount - 1) * horizontalSpacing} ${centerY}`;
      
      // Add branches
      for (let i = 0; i < newMilestones.length; i++) {
        const milestone = newMilestones[i];
        const x = startX + i * horizontalSpacing;
        pathDefinition += ` M ${x} ${centerY} L ${milestone.x} ${milestone.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateDiagonalStepsPattern(eventCount, virtualWidth, virtualHeight) {
      const startX = virtualWidth * 0.1;
      const startY = virtualHeight * 0.1;
      const endX = virtualWidth * 0.9;
      const endY = virtualHeight * 0.9;
      const stepSize = 80;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const baseX = startX + progress * (endX - startX);
        const baseY = startY + progress * (endY - startY);
        
        // Add step offset
        const stepOffset = (i % 2) * stepSize;
        const x = baseX + stepOffset;
        const y = baseY - stepOffset;
        
        newMilestones.push({ x, y });
        
        // Position slides to the side of steps
        const slideX = x + (i % 2 === 0 ? 20 : -260);
        newSlides.push({ x: slideX, y: y - 75 });
      }
      
      // Create diagonal stepped path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 1; i < newMilestones.length; i++) {
        const prev = newMilestones[i - 1];
        const curr = newMilestones[i];
        // Create diagonal steps
        const midX = (prev.x + curr.x) / 2;
        const midY = (prev.y + curr.y) / 2;
        pathDefinition += ` L ${midX} ${prev.y} L ${midX} ${midY} L ${curr.x} ${curr.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateCircularBranchPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth / 2;
      const centerY = virtualHeight / 2;
      const radius = Math.min(virtualWidth, virtualHeight) * 0.25;
      const branchLength = 120;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const angle = (i / eventCount) * 2 * Math.PI - Math.PI / 2; // Start from top
        
        // Hub position (on circle)
        const hubX = centerX + radius * Math.cos(angle);
        const hubY = centerY + radius * Math.sin(angle);
        
        // Branch extends outward from hub
        const branchX = hubX + branchLength * Math.cos(angle);
        const branchY = hubY + branchLength * Math.sin(angle);
        
        newMilestones.push({ x: branchX, y: branchY });
        
        // Position slide further out on branch
        const slideDistance = branchLength + 40;
        const slideX = hubX + slideDistance * Math.cos(angle) - 120;
        const slideY = hubY + slideDistance * Math.sin(angle) - 75;
        newSlides.push({ x: slideX, y: slideY });
      }
      
      // Create circular hub with radiating branches
      let pathDefinition = '';
      for (let i = 0; i < newMilestones.length; i++) {
        const angle = (i / eventCount) * 2 * Math.PI - Math.PI / 2;
        const hubX = centerX + radius * Math.cos(angle);
        const hubY = centerY + radius * Math.sin(angle);
        const milestone = newMilestones[i];
        
        if (i === 0) {
          pathDefinition = `M ${hubX} ${hubY}`;
        }
        pathDefinition += ` M ${hubX} ${hubY} L ${milestone.x} ${milestone.y}`;
      }
      
      // Add circular hub
      pathDefinition += ` M ${centerX + radius} ${centerY}`;
      pathDefinition += ` A ${radius} ${radius} 0 1 1 ${centerX - radius} ${centerY}`;
      pathDefinition += ` A ${radius} ${radius} 0 1 1 ${centerX + radius} ${centerY}`;
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateSConnectorPattern(eventCount, virtualWidth, virtualHeight) {
      const newMilestones = [];
      const newSlides = [];
      const amplitude = virtualWidth * 0.15;
      const centerX = virtualWidth / 2;
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const y = virtualHeight * 0.1 + progress * virtualHeight * 0.8;
        
        // Create flowing S-curve
        const sValue = Math.sin(progress * Math.PI * 1.5) * amplitude;
        const x = centerX + sValue;
        
        newMilestones.push({ x, y });
        
        // Position slides away from curve direction
        const isLeft = sValue < 0;
        const slideX = isLeft ? x - 350 : x + 110;
        newSlides.push({ x: slideX, y: y - 75 });
      }
      
      // Create smooth S-curve path with connectors to slides
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 1; i < newMilestones.length; i++) {
        const prev = newMilestones[i - 1];
        const curr = newMilestones[i];
        
        // Smooth S-curve
        const cp1X = prev.x;
        const cp1Y = prev.y + (curr.y - prev.y) * 0.6;
        const cp2X = curr.x;
        const cp2Y = curr.y - (curr.y - prev.y) * 0.6;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${curr.x} ${curr.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateMilestoneRoadPattern(eventCount, virtualWidth, virtualHeight) {
      const roadWidth = 100;
      const centerY = virtualHeight / 2;
      const spacing = virtualWidth * 0.8 / (eventCount - 1);
      const startX = virtualWidth * 0.1;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const x = startX + i * spacing;
        
        // Road curves gently up and down
        const curveOffset = Math.sin((i / eventCount) * Math.PI * 3) * 50;
        const y = centerY + curveOffset;
        
        newMilestones.push({ x, y });
        
        // Alternate slides above and below road
        const isAbove = i % 2 === 0;
        const slideY = isAbove ? y - 200 : y + 50;
        newSlides.push({ x: x - 120, y: slideY });
      }
      
      // Create road-like path with gentle curves
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 1; i < newMilestones.length; i++) {
        const prev = newMilestones[i - 1];
        const curr = newMilestones[i];
        const cp1X = prev.x + (curr.x - prev.x) * 0.4;
        const cp1Y = prev.y;
        const cp2X = curr.x - (curr.x - prev.x) * 0.4;
        const cp2Y = curr.y;
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${curr.x} ${curr.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateFlowingRiverPattern(eventCount, virtualWidth, virtualHeight) {
      const newMilestones = [];
      const newSlides = [];
      const riverWidth = virtualWidth * 0.9; // Use 90% of canvas width
      const startX = virtualWidth * 0.05; // Start from 5% edge
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const y = virtualHeight * 0.02 + progress * virtualHeight * 0.96; // Use 96% of height
        
        // Create wider meandering river path that spans the full canvas
        const meander1 = Math.sin(progress * Math.PI * 1.8) * riverWidth * 0.4; // Maximum amplitude
        const meander2 = Math.sin(progress * Math.PI * 2.7 + 1.2) * riverWidth * 0.2; // Secondary meander
        const x = startX + riverWidth * 0.5 + meander1 + meander2;
        
        newMilestones.push({ x, y });
        
        // Position slides on river banks with more spacing
        const bankSide = meander1 > 0 ? -1 : 1; // Opposite side of curve
        const slideX = x + bankSide * 200 + (bankSide < 0 ? -240 : 0);
        newSlides.push({ x: slideX, y: y - 75 });
      }
      
      // Create flowing river path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 1; i < newMilestones.length; i++) {
        const prev = newMilestones[i - 1];
        const curr = newMilestones[i];
        
        // Create natural river-like curves
        const distance = Math.sqrt(Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2));
        const tension = Math.min(distance * 0.3, 80);
        
        const cp1X = prev.x + (curr.x - prev.x) * 0.2;
        const cp1Y = prev.y + tension;
        const cp2X = curr.x - (curr.x - prev.x) * 0.2;
        const cp2Y = curr.y - tension;
        
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${curr.x} ${curr.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    // Advanced Curve Variation Patterns

    function generateLoopingRibbonPattern(eventCount, virtualWidth, virtualHeight) {
      const newMilestones = [];
      const newSlides = [];
      const amplitude = virtualHeight * 0.2;
      const centerY = virtualHeight / 2;
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const x = virtualWidth * 0.1 + progress * virtualWidth * 0.8;
        
        // Create multiple overlapping sine waves for complex ribbon effect
        const wave1 = Math.sin(progress * 2 * Math.PI) * amplitude * 0.6;
        const wave2 = Math.sin(progress * 3 * Math.PI + Math.PI/4) * amplitude * 0.3;
        const wave3 = Math.sin(progress * 5 * Math.PI + Math.PI/2) * amplitude * 0.2;
        const y = centerY + wave1 + wave2 + wave3;
        
        newMilestones.push({ x, y });
        newSlides.push({ x, y: y - 150 });
      }
      
      // Variable tangent lengths and directions for ribbon-like flow
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const progress = i / (eventCount - 1);
        
        // Calculate dynamic tangent direction based on local curve direction
        const prevPoint = i > 0 ? newMilestones[i - 1] : current;
        const nextNextPoint = i < newMilestones.length - 2 ? newMilestones[i + 2] : next;
        
        // Smooth directional tangents
        const incomingAngle = Math.atan2(current.y - prevPoint.y, current.x - prevPoint.x);
        const outgoingAngle = Math.atan2(nextNextPoint.y - next.y, nextNextPoint.x - next.x);
        
        const tangentLength = 60 + Math.sin(progress * 4 * Math.PI) * 20; // Variable length
        
        const cp1X = current.x + Math.cos(incomingAngle) * tangentLength;
        const cp1Y = current.y + Math.sin(incomingAngle) * tangentLength;
        const cp2X = next.x - Math.cos(outgoingAngle) * tangentLength;
        const cp2Y = next.y - Math.sin(outgoingAngle) * tangentLength;
        
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateElasticBouncePattern(eventCount, virtualWidth, virtualHeight) {
      const newMilestones = [];
      const newSlides = [];
      const baseY = virtualHeight * 0.6;
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const x = virtualWidth * 0.1 + progress * virtualWidth * 0.8;
        
        // Elastic bounce effect with varying amplitude
        const bounceFreq = 8;
        const decay = Math.exp(-progress * 3); // Exponential decay
        const bounce = Math.sin(progress * bounceFreq * Math.PI) * virtualHeight * 0.25 * decay;
        const y = baseY + bounce;
        
        newMilestones.push({ x, y });
        newSlides.push({ x, y: y - 150 });
      }
      
      // Dynamic control points that create elastic spring-like curves
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const progress = i / (eventCount - 1);
        
        // Calculate spring tension effect
        const springTension = 1 + Math.sin(progress * 8 * Math.PI) * 0.5;
        const dampening = Math.exp(-progress * 2);
        
        // Variable control point distances based on spring physics
        const cp1Distance = 40 * springTension * dampening;
        const cp2Distance = 30 * springTension * dampening;
        
        // Perpendicular tangents for spring effect
        const direction = Math.atan2(next.y - current.y, next.x - current.x);
        const perpendicular = direction + Math.PI/2;
        
        const cp1X = current.x + Math.cos(direction) * cp1Distance;
        const cp1Y = current.y + Math.sin(direction) * cp1Distance + Math.cos(perpendicular) * 20;
        const cp2X = next.x - Math.cos(direction) * cp2Distance;
        const cp2Y = next.y - Math.sin(direction) * cp2Distance + Math.cos(perpendicular) * -15;
        
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateTurbulentFlowPattern(eventCount, virtualWidth, virtualHeight) {
      const newMilestones = [];
      const newSlides = [];
      const centerY = virtualHeight / 2;
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const x = virtualWidth * 0.1 + progress * virtualWidth * 0.8;
        
        // Create turbulent flow with multiple frequency components
        const turbulence1 = Math.sin(progress * 7 * Math.PI) * virtualHeight * 0.1;
        const turbulence2 = Math.sin(progress * 13 * Math.PI + 1.5) * virtualHeight * 0.06;
        const turbulence3 = Math.sin(progress * 19 * Math.PI + 2.8) * virtualHeight * 0.04;
        const mainFlow = Math.sin(progress * 2 * Math.PI) * virtualHeight * 0.15;
        
        const y = centerY + mainFlow + turbulence1 + turbulence2 + turbulence3;
        
        newMilestones.push({ x, y });
        newSlides.push({ x, y: y - 150 });
      }
      
      // Chaotic but smooth control points for turbulent effect
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        const progress = i / (eventCount - 1);
        
        // Random-ish but deterministic control point variations
        const chaos1 = Math.sin(progress * 11 * Math.PI + 0.7) * 0.3;
        const chaos2 = Math.sin(progress * 17 * Math.PI + 1.9) * 0.4;
        
        // Varying control point distances and angles
        const baseDistance = (next.x - current.x) * 0.4;
        const cp1Distance = baseDistance * (1 + chaos1);
        const cp2Distance = baseDistance * (1 + chaos2);
        
        const cp1Angle = Math.atan2(next.y - current.y, next.x - current.x) + chaos1;
        const cp2Angle = Math.atan2(next.y - current.y, next.x - current.x) + chaos2;
        
        const cp1X = current.x + Math.cos(cp1Angle) * cp1Distance;
        const cp1Y = current.y + Math.sin(cp1Angle) * cp1Distance;
        const cp2X = next.x - Math.cos(cp2Angle) * cp2Distance;
        const cp2Y = next.y - Math.sin(cp2Angle) * cp2Distance;
        
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateCompanyMilestoneCurvePattern(eventCount, virtualWidth, virtualHeight) {
      const newMilestones = [];
      const newSlides = [];
      
      // Create a smooth, professional curved path that flows elegantly across the canvas
      const startX = virtualWidth * 0.1;
      const endX = virtualWidth * 0.9;
      const pathWidth = endX - startX;
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        
        // Smooth S-curve that flows naturally from left to right
        const x = startX + progress * pathWidth;
        
        // Create an elegant curve with gentle waves - similar to Alamy reference
        const primaryCurve = Math.sin(progress * Math.PI * 1.2) * virtualHeight * 0.25;
        const secondaryCurve = Math.sin(progress * Math.PI * 2.5 + Math.PI/4) * virtualHeight * 0.08;
        const baseY = virtualHeight * 0.5;
        const y = baseY + primaryCurve + secondaryCurve;
        
        newMilestones.push({ x, y });
        
        // Position slides alternately above and below the curve for balance
        const curveDirection = primaryCurve > 0 ? -1 : 1; // Opposite side of curve
        const slideOffsetY = curveDirection * 200; // Distance from curve
        const slideX = x + (curveDirection > 0 ? -250 : 20); // Offset to avoid overlap
        
        newSlides.push({ 
          x: slideX, 
          y: y + slideOffsetY - (curveDirection > 0 ? 150 : 0) 
        });
      }
      
      // Create smooth, professional curves between milestones - thick marker style
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      
      for (let i = 0; i < newMilestones.length - 1; i++) {
        const current = newMilestones[i];
        const next = newMilestones[i + 1];
        
        // Calculate curve direction for natural flow
        const deltaX = next.x - current.x;
        const deltaY = next.y - current.y;
        
        // Control points that create smooth, natural curves
        const controlDistance = deltaX * 0.4;
        
        // First control point - extends from current point
        const cp1X = current.x + controlDistance;
        const cp1Y = current.y;
        
        // Second control point - approaches next point
        const cp2X = next.x - controlDistance;
        const cp2Y = next.y;
        
        pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateDiamondRhombusPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth * 0.5;
      const centerY = virtualHeight * 0.5;
      const diamondWidth = virtualWidth * 0.35;
      const diamondHeight = virtualHeight * 0.4;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        
        // Create diamond/rhombus shape by mapping progress to diamond perimeter
        let x, y;
        
        if (progress <= 0.25) {
          // Top-right edge of diamond
          const t = progress * 4; // 0 to 1
          x = centerX + t * diamondWidth;
          y = centerY - (1 - t) * diamondHeight;
        } else if (progress <= 0.5) {
          // Bottom-right edge of diamond
          const t = (progress - 0.25) * 4; // 0 to 1
          x = centerX + (1 - t) * diamondWidth;
          y = centerY + t * diamondHeight;
        } else if (progress <= 0.75) {
          // Bottom-left edge of diamond
          const t = (progress - 0.5) * 4; // 0 to 1
          x = centerX - t * diamondWidth;
          y = centerY + (1 - t) * diamondHeight;
        } else {
          // Top-left edge of diamond
          const t = (progress - 0.75) * 4; // 0 to 1
          x = centerX - (1 - t) * diamondWidth;
          y = centerY - t * diamondHeight;
        }
        
        newMilestones.push({ x, y });
        
        // Position slides outside the diamond with outward offset
        const offsetDistance = 150;
        const angleToCenter = Math.atan2(centerY - y, centerX - x);
        const slideX = x + Math.cos(angleToCenter) * offsetDistance;
        const slideY = y + Math.sin(angleToCenter) * offsetDistance - 75;
        
        newSlides.push({ x: slideX, y: slideY });
      }
      
      // Create smooth diamond path with curved corners
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      
      for (let i = 0; i < newMilestones.length; i++) {
        const current = newMilestones[i];
        const next = newMilestones[(i + 1) % newMilestones.length];
        
        // Create smooth curves at diamond corners
        const controlDistance = 40;
        const currentProgress = i / (eventCount - 1);
        const nextProgress = ((i + 1) % eventCount) / (eventCount - 1);
        
        // Determine if we're at a corner (quarter points)
        const isCorner = Math.abs(currentProgress % 0.25) < 0.1 || Math.abs(nextProgress % 0.25) < 0.1;
        const curveStrength = isCorner ? controlDistance * 1.5 : controlDistance * 0.5;
        
        const cp1X = current.x + (next.x - current.x) * 0.3;
        const cp1Y = current.y + (next.y - current.y) * 0.3;
        const cp2X = current.x + (next.x - current.x) * 0.7;
        const cp2Y = current.y + (next.y - current.y) * 0.7;
        
        if (i === newMilestones.length - 1) {
          // Close the diamond shape
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${newMilestones[0].x} ${newMilestones[0].y}`;
        } else {
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
        }
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateHeartTeardropPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth * 0.5;
      const centerY = virtualHeight * 0.5;
      const scaleX = virtualWidth * 0.25;
      const scaleY = virtualHeight * 0.3;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        // Map progress from 0 to 2œÄ for heart parametric equations
        const t = progress * 2 * Math.PI;
        
        // Heart/teardrop parametric equations (cardioid)
        // x = a * (2*cos(t) - cos(2*t))
        // y = a * (2*sin(t) - sin(2*t))
        const heartX = scaleX * (2 * Math.cos(t) - Math.cos(2 * t));
        const heartY = scaleY * (2 * Math.sin(t) - Math.sin(2 * t));
        
        // Flip vertically so the point is at the bottom (like your drawing)
        const x = centerX + heartX;
        const y = centerY - heartY + scaleY * 0.5; // Offset to center properly
        
        newMilestones.push({ x, y });
        
        // Position slides outside the heart shape
        const offsetDistance = 120;
        // Calculate outward direction from heart center
        const angleFromCenter = Math.atan2(y - centerY, x - centerX);
        const slideX = x + Math.cos(angleFromCenter) * offsetDistance;
        const slideY = y + Math.sin(angleFromCenter) * offsetDistance - 75;
        
        newSlides.push({ x: slideX, y: slideY });
      }
      
      // Create smooth heart-shaped path
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      
      for (let i = 0; i < newMilestones.length; i++) {
        const current = newMilestones[i];
        const next = newMilestones[(i + 1) % newMilestones.length];
        
        // Calculate tangent direction for smooth heart curves
        const currentProgress = i / (eventCount - 1);
        const t = currentProgress * 2 * Math.PI;
        
        // Tangent vector for heart shape
        const tangentX = scaleX * (-2 * Math.sin(t) + 2 * Math.sin(2 * t));
        const tangentY = -scaleY * (2 * Math.cos(t) - 2 * Math.cos(2 * t)); // Flipped
        
        // Normalize tangent and create control points
        const tangentLength = Math.sqrt(tangentX * tangentX + tangentY * tangentY);
        const normalizedTangentX = tangentX / tangentLength;
        const normalizedTangentY = tangentY / tangentLength;
        
        const controlDistance = 30;
        const cp1X = current.x + normalizedTangentX * controlDistance;
        const cp1Y = current.y + normalizedTangentY * controlDistance;
        const cp2X = next.x - normalizedTangentX * controlDistance;
        const cp2Y = next.y - normalizedTangentY * controlDistance;
        
        if (i === newMilestones.length - 1) {
          // Close the heart shape
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${newMilestones[0].x} ${newMilestones[0].y}`;
        } else {
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
        }
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateStarAsteriskPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth * 0.5;
      const centerY = virtualHeight * 0.5;
      const outerRadius = Math.min(virtualWidth, virtualHeight) * 0.35;
      const innerRadius = outerRadius * 0.4;
      const numPoints = 8; // 8-pointed star like your drawing
      const newMilestones = [];
      const newSlides = [];
      
      // Create star points by alternating between outer and inner radius
      const starPoints = [];
      for (let i = 0; i < numPoints * 2; i++) {
        const angle = (i * Math.PI) / numPoints - Math.PI / 2; // Start from top
        const radius = i % 2 === 0 ? outerRadius : innerRadius;
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);
        starPoints.push({ x, y });
      }
      
      // Distribute timeline events around the star perimeter
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const totalPerimeter = starPoints.length;
        const position = progress * (totalPerimeter - 1);
        const segmentIndex = Math.floor(position);
        const segmentProgress = position - segmentIndex;
        
        // Interpolate between star points
        const currentPoint = starPoints[segmentIndex];
        const nextPoint = starPoints[(segmentIndex + 1) % starPoints.length];
        
        const x = currentPoint.x + (nextPoint.x - currentPoint.x) * segmentProgress;
        const y = currentPoint.y + (nextPoint.y - currentPoint.y) * segmentProgress;
        
        newMilestones.push({ x, y });
        
        // Position slides at the tips of star points (outward direction)
        const slideDistance = 140;
        const angleFromCenter = Math.atan2(y - centerY, x - centerX);
        const slideX = x + Math.cos(angleFromCenter) * slideDistance;
        const slideY = y + Math.sin(angleFromCenter) * slideDistance - 75;
        
        newSlides.push({ x: slideX, y: slideY });
      }
      
      // Create star path with sharp points and smooth curves
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      
      for (let i = 0; i < newMilestones.length; i++) {
        const current = newMilestones[i];
        const next = newMilestones[(i + 1) % newMilestones.length];
        
        // Determine if we're at a star point (outer radius) or valley (inner radius)
        const currentDistance = Math.sqrt(Math.pow(current.x - centerX, 2) + Math.pow(current.y - centerY, 2));
        const nextDistance = Math.sqrt(Math.pow(next.x - centerX, 2) + Math.pow(next.y - centerY, 2));
        
        const isCurrentOuter = currentDistance > (outerRadius + innerRadius) / 2;
        const isNextOuter = nextDistance > (outerRadius + innerRadius) / 2;
        
        // Create sharp points at star tips, smooth curves elsewhere
        let controlDistance;
        if (isCurrentOuter || isNextOuter) {
          controlDistance = 15; // Sharp points at star tips
        } else {
          controlDistance = 35; // Smooth curves in valleys
        }
        
        const cp1X = current.x + (next.x - current.x) * 0.2;
        const cp1Y = current.y + (next.y - current.y) * 0.2;
        const cp2X = current.x + (next.x - current.x) * 0.8;
        const cp2Y = current.y + (next.y - current.y) * 0.8;
        
        if (i === newMilestones.length - 1) {
          // Close the star shape
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${newMilestones[0].x} ${newMilestones[0].y}`;
        } else {
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
        }
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateCloudOrganicPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth * 0.5;
      const centerY = virtualHeight * 0.5;
      const baseRadius = Math.min(virtualWidth, virtualHeight) * 0.25;
      const newMilestones = [];
      const newSlides = [];
      
      // Create organic cloud-like shape with varying radius
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        const angle = progress * 2 * Math.PI;
        
        // Create organic bulges and indentations like your cloud drawing
        const bulge1 = Math.sin(angle * 3) * 0.3; // Primary bulges
        const bulge2 = Math.sin(angle * 5 + 1.2) * 0.15; // Secondary variation
        const bulge3 = Math.sin(angle * 7 + 2.4) * 0.08; // Fine detail
        const noise = Math.sin(angle * 11 + 3.6) * 0.05; // Organic noise
        
        // Combine variations for natural cloud-like outline
        const radiusVariation = 1 + bulge1 + bulge2 + bulge3 + noise;
        const radius = baseRadius * radiusVariation;
        
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);
        
        newMilestones.push({ x, y });
        
        // Position slides outside the cloud with organic spacing
        const slideDistance = 130 + Math.abs(bulge1) * 40; // Variable distance based on bulge
        const slideX = x + Math.cos(angle) * slideDistance;
        const slideY = y + Math.sin(angle) * slideDistance - 75;
        
        newSlides.push({ x: slideX, y: slideY });
      }
      
      // Create smooth, flowing cloud path with organic curves
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      
      for (let i = 0; i < newMilestones.length; i++) {
        const current = newMilestones[i];
        const next = newMilestones[(i + 1) % newMilestones.length];
        
        // Calculate organic curve strength based on radius variations
        const currentProgress = i / (eventCount - 1);
        const nextProgress = ((i + 1) % eventCount) / (eventCount - 1);
        
        const currentAngle = currentProgress * 2 * Math.PI;
        const nextAngle = nextProgress * 2 * Math.PI;
        
        // Vary control point distance for organic feel
        const currentBulge = Math.sin(currentAngle * 3) * 0.3;
        const nextBulge = Math.sin(nextAngle * 3) * 0.3;
        
        const controlDistance = 25 + Math.abs(currentBulge + nextBulge) * 20;
        
        // Create tangent directions that follow the cloud's organic flow
        const currentRadius = Math.sqrt(Math.pow(current.x - centerX, 2) + Math.pow(current.y - centerY, 2));
        const nextRadius = Math.sqrt(Math.pow(next.x - centerX, 2) + Math.pow(next.y - centerY, 2));
        
        // Tangent direction perpendicular to radius for smooth cloud curves
        const currentTangentAngle = currentAngle + Math.PI / 2;
        const nextTangentAngle = nextAngle + Math.PI / 2;
        
        const cp1X = current.x + Math.cos(currentTangentAngle) * controlDistance;
        const cp1Y = current.y + Math.sin(currentTangentAngle) * controlDistance;
        const cp2X = next.x - Math.cos(nextTangentAngle) * controlDistance;
        const cp2Y = next.y - Math.sin(nextTangentAngle) * controlDistance;
        
        if (i === newMilestones.length - 1) {
          // Close the cloud shape
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${newMilestones[0].x} ${newMilestones[0].y}`;
        } else {
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
        }
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    function generateInfinityLoopPattern(eventCount, virtualWidth, virtualHeight) {
      const centerX = virtualWidth * 0.5;
      const centerY = virtualHeight * 0.5;
      const scaleX = virtualWidth * 0.3;
      const scaleY = virtualHeight * 0.2;
      const newMilestones = [];
      const newSlides = [];
      
      for (let i = 0; i < eventCount; i++) {
        const progress = i / (eventCount - 1);
        // Map progress to infinity symbol parametric equations
        const t = progress * 4 * Math.PI; // Full infinity loop
        
        // Infinity symbol (lemniscate) parametric equations
        // x = a * cos(t) / (1 + sin¬≤(t))
        // y = a * sin(t) * cos(t) / (1 + sin¬≤(t))
        const sinT = Math.sin(t);
        const cosT = Math.cos(t);
        const denominator = 1 + sinT * sinT;
        
        const infinityX = scaleX * cosT / denominator;
        const infinityY = scaleY * sinT * cosT / denominator;
        
        const x = centerX + infinityX;
        const y = centerY + infinityY;
        
        newMilestones.push({ x, y });
        
        // Position slides outside the infinity loop
        const offsetDistance = 120;
        // Calculate outward direction based on current position on infinity curve
        let slideAngle;
        
        // Determine which loop we're on and position slides accordingly
        if (Math.abs(infinityX) > scaleX * 0.1) {
          // On the sides of the infinity - position slides outward
          slideAngle = infinityX > 0 ? 0 : Math.PI; // Right or left
        } else {
          // At the center crossing - position slides up or down
          slideAngle = infinityY > 0 ? Math.PI/2 : -Math.PI/2; // Up or down
        }
        
        const slideX = x + Math.cos(slideAngle) * offsetDistance;
        const slideY = y + Math.sin(slideAngle) * offsetDistance - 75;
        
        newSlides.push({ x: slideX, y: slideY });
      }
      
      // Create smooth infinity path with proper curve transitions
      let pathDefinition = `M ${newMilestones[0].x} ${newMilestones[0].y}`;
      
      for (let i = 0; i < newMilestones.length; i++) {
        const current = newMilestones[i];
        const next = newMilestones[(i + 1) % newMilestones.length];
        
        // Calculate tangent direction for smooth infinity curves
        const currentProgress = i / (eventCount - 1);
        const t = currentProgress * 4 * Math.PI;
        
        // Derivative of infinity curve for tangent calculation
        const sinT = Math.sin(t);
        const cosT = Math.cos(t);
        const denominator = 1 + sinT * sinT;
        const denominatorSq = denominator * denominator;
        
        // Tangent vector components
        const tangentX = scaleX * (-sinT * denominator - cosT * 2 * sinT * cosT) / denominatorSq;
        const tangentY = scaleY * ((cosT * cosT - sinT * sinT) * denominator - sinT * cosT * 2 * sinT * cosT) / denominatorSq;
        
        // Normalize tangent and create control points
        const tangentLength = Math.sqrt(tangentX * tangentX + tangentY * tangentY) || 1;
        const normalizedTangentX = tangentX / tangentLength;
        const normalizedTangentY = tangentY / tangentLength;
        
        const controlDistance = 25;
        const cp1X = current.x + normalizedTangentX * controlDistance;
        const cp1Y = current.y + normalizedTangentY * controlDistance;
        const cp2X = next.x - normalizedTangentX * controlDistance;
        const cp2Y = next.y - normalizedTangentY * controlDistance;
        
        if (i === newMilestones.length - 1) {
          // Close the infinity shape
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${newMilestones[0].x} ${newMilestones[0].y}`;
        } else {
          pathDefinition += ` C ${cp1X} ${cp1Y} ${cp2X} ${cp2Y} ${next.x} ${next.y}`;
        }
      }
      
      const resolvedSlides = resolveSlideOverlaps(newSlides, newMilestones);
      return { milestones: newMilestones, slides: resolvedSlides, pathDefinition };
    }

    // Collision Detection and Resolution with Milestone Association
    function resolveSlideOverlaps(slides, milestones) {
      const slideWidth = 240;
      const slideHeight = 150;
      const minGap = 20; // Minimum gap between slides
      const resolvedSlides = [...slides];
      
      // Multiple passes to resolve all overlaps
      let maxIterations = 10;
      let overlapsFound = true;
      
      while (overlapsFound && maxIterations > 0) {
        overlapsFound = false;
        
        // Check for overlaps and resolve them
        for (let i = 0; i < resolvedSlides.length; i++) {
          for (let j = i + 1; j < resolvedSlides.length; j++) {
            const slide1 = resolvedSlides[i];
            const slide2 = resolvedSlides[j];
            
            // Check if slides overlap
            if (slidesOverlap(slide1, slide2, slideWidth, slideHeight)) {
              overlapsFound = true;
              
              // Get corresponding milestones
              const milestone1 = milestones ? milestones[i] : null;
              const milestone2 = milestones ? milestones[j] : null;
              
              // Resolve overlap by moving both slides to maintain milestone association
              const newPositions = repositionSlidesWithMilestones(
                slide1, slide2, milestone1, milestone2, i, j, 
                slideWidth, slideHeight, minGap
              );
              
              resolvedSlides[i] = newPositions.slide1;
              resolvedSlides[j] = newPositions.slide2;
            }
          }
        }
        
        maxIterations--;
      }
      
      return resolvedSlides;
    }
    
    function slidesOverlap(slide1, slide2, width, height) {
      return !(slide1.x + width < slide2.x || 
               slide2.x + width < slide1.x || 
               slide1.y + height < slide2.y || 
               slide2.y + height < slide1.y);
    }
    
    function repositionSlidesWithMilestones(slide1, slide2, milestone1, milestone2, index1, index2, width, height, minGap) {
      const totalWidth = width + minGap;
      const totalHeight = height + minGap;
      
      // Calculate preferred positions relative to milestones
      const getPreferredPositions = (milestone, slideIndex) => {
        if (!milestone) return [];
        
        return [
          { x: milestone.x - width/2, y: milestone.y - height }, // Above, centered
          { x: milestone.x - width/2, y: milestone.y + 20 }, // Below, centered
          { x: milestone.x + 30, y: milestone.y - height/2 }, // Right
          { x: milestone.x - width - 30, y: milestone.y - height/2 }, // Left
          { x: milestone.x + 30, y: milestone.y - height }, // Top-right
          { x: milestone.x - width - 30, y: milestone.y - height }, // Top-left
          { x: milestone.x + 30, y: milestone.y + 20 }, // Bottom-right
          { x: milestone.x - width - 30, y: milestone.y + 20 } // Bottom-left
        ];
      };
      
      const positions1 = getPreferredPositions(milestone1, index1);
      const positions2 = getPreferredPositions(milestone2, index2);
      
      // Find best non-overlapping positions
      for (const pos1 of positions1) {
        for (const pos2 of positions2) {
          // Check if positions are valid (within bounds)
          if (isValidPosition(pos1, width, height) && isValidPosition(pos2, width, height)) {
            // Check if they don't overlap with each other
            if (!positionsOverlap(pos1, pos2, width, height)) {
              return { slide1: pos1, slide2: pos2 };
            }
          }
        }
      }
      
      // Fallback: spread them apart horizontally while keeping milestone association
      const fallback1 = milestone1 ? 
        { x: milestone1.x - width - 50, y: milestone1.y - height } :
        { x: slide1.x - totalWidth, y: slide1.y };
      const fallback2 = milestone2 ? 
        { x: milestone2.x + 50, y: milestone2.y - height } :
        { x: slide2.x + totalWidth, y: slide2.y };
        
      return { slide1: fallback1, slide2: fallback2 };
    }
    
    function isValidPosition(pos, width, height) {
      return pos.x >= 0 && pos.x + width <= 1920 && 
             pos.y >= 0 && pos.y + height <= 1080;
    }
    
    function positionsOverlap(pos1, pos2, width, height) {
      return !(pos1.x + width < pos2.x || 
               pos2.x + width < pos1.x || 
               pos1.y + height < pos2.y || 
               pos2.y + height < pos1.y);
    }

    function highlightOverlappingSlides() {
      const slides = document.querySelectorAll('.slide');
      const canvas = document.getElementById('canvas');
      const canvasRect = canvas.getBoundingClientRect();
      const scaleX = canvasRect.width / positions.virtualCanvas.width;
      const scaleY = canvasRect.height / positions.virtualCanvas.height;
      
      const SLIDE_WIDTH = 240;
      const SLIDE_BASE_HEIGHT = 150;
      const IMAGE_HEIGHT = 120;
      const IMAGE_MARGIN = 10;
      
      console.log('üîç Checking for overlaps...', {
        slideCount: slides.length,
        positionsCount: positions.slidePositions.length
      });
      
      // First, clear all existing warnings and borders from ALL slides
      slides.forEach((slide, index) => {
        slide.style.border = '';
        slide.style.removeProperty('border');
        const existingWarnings = slide.querySelectorAll('.overlap-warning');
        existingWarnings.forEach(warning => warning.remove());
        console.log(`Cleared warnings from slide ${index}`);
      });
      
      // Track which slides have overlaps
      const overlappingSlides = new Set();
      
      // Check each slide against all other slides
      for (let i = 0; i < positions.slidePositions.length; i++) {
        const pos1 = positions.slidePositions[i];
        if (!pos1) continue;
        
        // Calculate actual height for slide 1
        const event1 = events[i];
        const hasImage1 = event1 && event1.image && event1.image.length > 0;
        const height1 = SLIDE_BASE_HEIGHT + (hasImage1 ? IMAGE_HEIGHT + IMAGE_MARGIN : 0);
        
        for (let j = i + 1; j < positions.slidePositions.length; j++) {
          const pos2 = positions.slidePositions[j];
          if (!pos2) continue;
          
          // Calculate actual height for slide 2
          const event2 = events[j];
          const hasImage2 = event2 && event2.image && event2.image.length > 0;
          const height2 = SLIDE_BASE_HEIGHT + (hasImage2 ? IMAGE_HEIGHT + IMAGE_MARGIN : 0);
          
          // Check if slides overlap using the actual dimensions
          const overlap = !(
            pos1.x + SLIDE_WIDTH <= pos2.x || 
            pos2.x + SLIDE_WIDTH <= pos1.x || 
            pos1.y + height1 <= pos2.y || 
            pos2.y + height2 <= pos1.y
          );
          
          if (overlap) {
            overlappingSlides.add(i);
            overlappingSlides.add(j);
            console.log(`üö® Overlap detected between slides ${i} and ${j}`, {
              slide1: { x: pos1.x, y: pos1.y, height: height1, hasImage: hasImage1 },
              slide2: { x: pos2.x, y: pos2.y, height: height2, hasImage: hasImage2 }
            });
          }
        }
      }
      
      console.log(`Found ${overlappingSlides.size} overlapping slides:`, Array.from(overlappingSlides));
      
      // Apply warnings only to slides that are actually overlapping
      overlappingSlides.forEach(slideIndex => {
        const slide = slides[slideIndex];
        if (slide) {
          // Add red border with !important to ensure it applies
          slide.style.setProperty('border', '3px solid #ff4444', 'important');
          
          // Add warning icon
          const warning = document.createElement('div');
          warning.className = 'overlap-warning';
          warning.innerHTML = '‚ö†Ô∏è';
          warning.style.cssText = `
            position: absolute;
            top: -10px;
            right: -10px;
            background: #ff4444;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            z-index: 1000;
            pointer-events: none;
          `;
          slide.appendChild(warning);
          console.log(`‚úÖ Applied warning to slide ${slideIndex}`);
        }
      });
      
      if (overlappingSlides.size === 0) {
        console.log('‚úÖ No overlaps detected - all warnings cleared');
      }
    }

    // Theme Management Functions
    let themes = {
      "cosmic": {
        "name": "Cosmic Dark",
        "description": "Purple and blue cosmic theme with glowing effects",
        "colors": {
          "background": "#111",
          "containerBackground": "transparent",
          "textPrimary": "#fff",
          "textSecondary": "rgba(255, 255, 255, 0.8)",
          "pathGradient": {
            "start": "#8A2BE2",
            "middle": "#1E90FF", 
            "end": "#FF69B4"
          },
          "milestones": [
            "#8A2BE2",
            "#1E90FF", 
            "#00CED1",
            "#9370DB",
            "#FF69B4"
          ],
          "activeMilestone": "#8A2BE2",
          "controls": {
            "background": "rgba(255, 255, 255, 0.1)",
            "border": "rgba(255, 255, 255, 0.2)",
            "hover": "rgba(255, 255, 255, 0.2)",
            "zoomOutBorder": "#8A2BE2",
            "zoomOutHover": "rgba(138, 43, 226, 0.15)"
          }
        },
        "effects": {
          "pathGlow": "drop-shadow(0 0 12px rgba(100, 100, 255, 0.5))",
          "milestoneGlow": "0 0 0 4px rgba(255, 255, 255, 0.3), 0 0 10px rgba(255, 255, 255, 0.5)",
          "activeMilestoneGlow": "0 0 0 6px rgba(138, 43, 226, 0.4), 0 0 20px rgba(138, 43, 226, 0.8)",
          "controlsBackdrop": "blur(10px)",
          "controlsShadow": "0 4px 30px rgba(0, 0, 0, 0.1)"
        },
        "dimensions": {
          "pathWidth": 20,
          "milestoneSize": 24,
          "activeMilestoneSize": 32,
          "controlSize": 60,
          "slideOpacity": 0.1,
          "slideActiveOpacity": 1
        }
      },
      "minimal": {
        "name": "Minimal Light",
        "description": "Clean, minimal theme with subtle colors",
        "colors": {
          "background": "#f5f5f5",
          "containerBackground": "transparent",
          "textPrimary": "#333",
          "textSecondary": "rgba(51, 51, 51, 0.7)",
          "pathGradient": {
            "start": "#666",
            "middle": "#888",
            "end": "#666"
          },
          "milestones": [
            "#4A90E2",
            "#7ED321",
            "#F5A623",
            "#D0021B",
            "#9013FE"
          ],
          "activeMilestone": "#4A90E2",
          "controls": {
            "background": "rgba(255, 255, 255, 0.9)",
            "border": "rgba(0, 0, 0, 0.1)",
            "hover": "rgba(0, 0, 0, 0.05)",
            "zoomOutBorder": "#4A90E2",
            "zoomOutHover": "rgba(74, 144, 226, 0.1)"
          }
        },
        "effects": {
          "pathGlow": "none",
          "milestoneGlow": "0 2px 8px rgba(0, 0, 0, 0.1)",
          "activeMilestoneGlow": "0 4px 16px rgba(74, 144, 226, 0.3)",
          "controlsBackdrop": "blur(5px)",
          "controlsShadow": "0 2px 20px rgba(0, 0, 0, 0.1)"
        },
        "dimensions": {
          "pathWidth": 16,
          "milestoneSize": 20,
          "activeMilestoneSize": 28,
          "controlSize": 50,
          "slideOpacity": 0.2,
          "slideActiveOpacity": 1
        }
      }
    };

    let currentThemeKey = 'cosmic';

    function switchTheme() {
      const selector = document.getElementById('theme-selector');
      const selectedTheme = selector.value;
      const theme = themes[selectedTheme];
      
      if (theme) {
        currentThemeKey = selectedTheme;
        updateThemePreview(theme);
      }
    }

    function updateThemePreview(theme) {
      const themeInfo = document.getElementById('theme-info');
      themeInfo.innerHTML = `
        <strong>${theme.name}</strong><br>
        <small style="color: #bbb;">${theme.description}</small>
      `;
    }

    async function applySelectedTheme() {
      const themeData = {
        currentTheme: currentThemeKey,
        themes: themes
      };

      // Create and download the theme.json file
      const themeJson = JSON.stringify(themeData, null, 2);
      const blob = new Blob([themeJson], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = 'theme.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showTempMessage(`üé® Applied ${themes[currentThemeKey].name} theme! Download and replace theme.json file.`);
    }

    async function downloadTheme() {
      const themeData = {
        currentTheme: currentThemeKey,
        themes: themes
      };

      const themeJson = JSON.stringify(themeData, null, 2);
      const blob = new Blob([themeJson], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = 'theme.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showTempMessage('üíæ theme.json downloaded!');
    }

    // Initialize theme selector
    document.addEventListener('DOMContentLoaded', () => {
      switchTheme(); // Set initial theme preview
    });
    
    function createSaveScript() {
      // Create a simple PHP script that can save the positions
      const phpScript = `<?php
header('Content-Type: application/json');
header('Access-Control-Allow-Origin: *');
header('Access-Control-Allow-Methods: POST');
header('Access-Control-Allow-Headers: Content-Type');

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $input = file_get_contents('php://input');
    $data = json_decode($input, true);
    
    if ($data) {
        $result = file_put_contents('positions.json', json_encode($data, JSON_PRETTY_PRINT));
        if ($result !== false) {
            echo json_encode(['success' => true]);
        } else {
            http_response_code(500);
            echo json_encode(['error' => 'Failed to write file']);
        }
    } else {
        http_response_code(400);
        echo json_encode(['error' => 'Invalid JSON']);
    }
} else {
    http_response_code(405);
    echo json_encode(['error' => 'Method not allowed']);
}
?>`;

      // Download the PHP script
      const blob1 = new Blob([phpScript], { type: 'text/plain' });
      const url1 = URL.createObjectURL(blob1);
      const a1 = document.createElement('a');
      a1.href = url1;
      a1.download = 'save-positions.php';
      document.body.appendChild(a1);
      a1.click();
      document.body.removeChild(a1);
      URL.revokeObjectURL(url1);
      
      // Also download the updated positions.json as backup
      const dataStr = JSON.stringify(positions, null, 2);
      const blob2 = new Blob([dataStr], { type: 'application/json' });
      const url2 = URL.createObjectURL(blob2);
      const a2 = document.createElement('a');
      a2.href = url2;
      a2.download = 'positions.json';
      document.body.appendChild(a2);
      a2.click();
      document.body.removeChild(a2);
      URL.revokeObjectURL(url2);
      
      alert('üìÅ Downloaded save-positions.php script and updated positions.json!\n\n' +
            '1. Place save-positions.php in your web server directory\n' +
            '2. Replace the old positions.json with the new one\n' +
            '3. Future saves will work automatically!');
    }

    function previewTimeline() {
      window.open('index.html', '_blank');
    }

    function showTemplatesModal() {
      document.getElementById('templates-modal').style.display = 'block';
    }

    function closeTemplatesModal() {
      document.getElementById('templates-modal').style.display = 'none';
    }

    // Close modal when clicking outside of it
    window.addEventListener('click', (event) => {
      const modal = document.getElementById('templates-modal');
      if (event.target === modal) {
        closeTemplatesModal();
      }
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      renderElements();
    });

    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOM loaded, initializing settings page');
      // Initialize template display
      updateTemplateDisplay('Loading...');
      loadPositions();
    });
    
    // Also try immediate initialization in case DOM is already loaded
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      console.log('DOM already ready, initializing settings page');
      loadPositions();
    }
  </script>
</body>
</html>